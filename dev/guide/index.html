<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · GEBT.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GEBT.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Getting Started</a><ul class="internal"><li><a class="tocitem" href="#Creating-an-Assembly"><span>Creating an Assembly</span></a></li><li><a class="tocitem" href="#Defining-Distributed-Loads"><span>Defining Distributed Loads</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting Started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/GEBT.jl/blob/master/docs/src/guide.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Getting-Started"><a class="docs-heading-anchor" href="#Getting-Started">Getting Started</a><a id="Getting-Started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Started" title="Permalink"></a></h1><p>In this guide we introduce you to the functionality of this package in a step by step manner.  This is a good starting point for learning about how to use this package.  For more details about how to use a particular function the <a href="../library/#Public-API">Public API</a> is likely a better resource.  For more examples of how to use this package see the <a href="../examples/#Examples">examples</a>.</p><p>If you haven&#39;t yet, now would be a good time to install GEBT.  GEBT can be installed from the Julia REPL by typing <code>]</code> (to enter the package manager) and then running the following command.</p><pre><code class="language-julia">pkg&gt; add https://github.com/byuflowlab/GEBT.jl</code></pre><p>Now, that the package is installed we need to load it so that we can use it.  It&#39;s also often helpful to load the LinearAlgebra package.</p><pre><code class="language-julia">using GEBT, LinearAlgebra</code></pre><p>The geometry we will be working with is a rotating beam with a swept tip as pictured.</p><p><img src="../rotating-beam-drawing.svg" alt/></p><p>This geometry has a fixed boundary condition on the left side of the beam and rotates around a point 2.5 inches to the left of the beam.  We will investigating the steady behavior of this system for a variety of RPM settings at a constant sweep of 45°.</p><h2 id="Creating-an-Assembly"><a class="docs-heading-anchor" href="#Creating-an-Assembly">Creating an Assembly</a><a id="Creating-an-Assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-an-Assembly" title="Permalink"></a></h2><p>The first step for any analysis is to create an object of type <code>Assembly</code>.  This object stores the properties of each of the points and beam elements in our model.  </p><p>To create an object of type Assembly we need the following:</p><ul><li>An array of points</li><li>The starting point for each beam element</li><li>The ending point for each beam element</li><li>The stiffness or compliance matrix for each beam element</li><li>The mass or inverse mass matrix for each beam element (for dynamic simulations)</li><li>Rotation matrices for each beam element which transform from the global frame to the undeformed local beam frame.</li></ul><p>In case the beam elements are curved we can also manually provide the length and midpoint of each beam element.  This is not necessary for straight beam elements.</p><p>We will first focus on the geometry.  We start by defining the straight section of the beam.  This section extends from (2.5, 0, 0) to (34, 0, 0).  Its local undeformed coordinate frame is the same as the global coordinate frame.  We will discretize this section into 10 elements.</p><p>To aid with constructing the geometry we can use the <code>discretize_beam</code> function.  Here we will pass in the length, starting point, and number of elements.  The function returns the lengths, endpoints, midpoints, and frame of each beam element.</p><pre><code class="language-julia"># straight section of the beam
L_b1 = 31.5 # length of straight section of the beam in inches
r_b1 = [2.5, 0, 0] # starting point of straight section of the beam
nelem_b1 = 10 # number of elements in the straight section of the beam
lengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1)</code></pre><p>The lengths of each beam element is equal since we used the number of elements to define the discretization.  Alternatively we can manually specify the discretization of the section. The following is equivalent to the previous function call.</p><pre><code class="language-julia">disc_b1 = range(0, 1, length=nelem_b1+1) # normalized discretization in straight section of the beam
lengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, disc_b1)</code></pre><p>We will now create the geometry for the swept portion of the wing.  To do so we use the same <code>discretize_beam</code> function, with an additional argument that allows us to specify a rotation matrix which transforms from the global frame to the undeformed frame of the starting point of this beam section.</p><pre><code class="language-julia">sweep = 45 * pi/180

# swept section of the beam
L_b2 = 6 # length of swept section of the beam
r_b2 = [34, 0, 0] # starting point of swept section of the beam
nelem_b2 = 5 # number of elements in swept section of the beam
cs, ss = cos(sweep), sin(sweep)
frame_b2 = [cs ss 0; -ss cs 0; 0 0 1] # transformation matrix from global to local frame
lengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2, frame=frame_b2)</code></pre><p>If either of these beam sections were curved we would have also had to pass in a curvature vector to <code>discretize_beam</code>.</p><p>We will now manually combine the results of our two calls to <code>discretize_beam</code>.  Since the last endpoint from the straight section is the same as the first endpoint of the swept section we drop one of the endpoints when combining our results.</p><pre><code class="language-julia"># combine elements and points into one array
nelem = nelem_b1 + nelem_b2 # total number of elements
points = vcat(xp_b1, xp_b2[2:end]) # all points in our assembly
start = 1:nelem_b1 + nelem_b2 # starting point of each beam element in our assembly
stop = 2:nelem_b1 + nelem_b2 + 1 # ending point of each beam element in our assembly
lengths = vcat(lengths_b1, lengths_b2) # length of each beam element in our assembly
midpoints = vcat(xm_b1, xm_b2) # midpoint of each beam element in our assembly
Cab = vcat(Cab_b1, Cab_b2) # transformation matrix from global to local frame for each beam element in our assembly</code></pre><p>Next we need to define the stiffness (or compliance) and mass (or inverse mass) matrices for each beam element.</p><p>The compliance matrix is defined according to the following equation</p><div>\[\begin{bmatrix}
\gamma_{11} \\
2\gamma_{12} \\
2\gamma_{13} \\
\kappa_{1} \\
\kappa_{2} \\
\kappa_{3}
\end{bmatrix}
=
\begin{bmatrix}
   S_{11} &amp; S_{12} &amp; S_{13} &amp; S_{14} &amp; S_{15} &amp; S_{16} \\
   S_{12} &amp; S_{22} &amp; S_{23} &amp; S_{24} &amp; S_{25} &amp; S_{26} \\
   S_{13} &amp; S_{23} &amp; S_{33} &amp; S_{34} &amp; S_{35} &amp; S_{36} \\
   S_{14} &amp; S_{24} &amp; S_{43} &amp; S_{44} &amp; S_{45} &amp; S_{46} \\
   S_{15} &amp; S_{25} &amp; S_{35} &amp; S_{45} &amp; S_{55} &amp; S_{56} \\
   S_{16} &amp; S_{26} &amp; S_{36} &amp; S_{46} &amp; S_{56} &amp; S_{66}
\end{bmatrix}
\begin{bmatrix}
   F_{1} \\
   F_{2} \\
   F_{3} \\
   M_{1} \\
   M_{2} \\
   M_{3}
\end{bmatrix}\]</div><p>with the variables defined as follows:</p><ul><li><span>$\gamma_{11}$</span>: beam axial strain</li><li><span>$2\gamma_{12}$</span> engineering transverse strain along axis 2</li><li><span>$2\gamma_{13}$</span> engineering transverse strain along axis 3</li><li><span>$\kappa_1$</span>: twist</li><li><span>$\kappa_2$</span>: curvature about axis 2</li><li><span>$\kappa_3$</span>: curvature about axis 3</li><li><span>$F_i$</span>: resultant force about axis i</li><li><span>$M_i$</span>: resultant moment about axis i</li></ul><p>The elements of the mass matrix are defined as:</p><div>\[\begin{bmatrix}
   \mu &amp; 0 &amp; 0 &amp; 0 &amp; \mu x_{m3} &amp; -\mu x_{m2} \\
   0 &amp; \mu &amp; 0 &amp; -\mu x_{m3} &amp; 0 &amp; 0 \\
   0 &amp; 0 &amp; \mu &amp; \mu x_{m2} &amp; 0 &amp; 0 \\
   0 &amp; -\mu x_{m3} &amp; \mu x_{m2} &amp; i_{22} + i_{33} &amp; 0 &amp; 0 \\
   \mu x_{m3}  &amp; 0 &amp; 0 &amp; 0 &amp; i_{22} &amp; -i_{23} \\
   -\mu x_{m2} &amp; 0 &amp; 0 &amp; 0 &amp; -i_{23} &amp; i_{33}
\end{bmatrix}\]</div><p>with the variables defined as follows:</p><ul><li><span>$\mu$</span>: mass per unit length</li><li><span>$(x_{m2}, x_{m3})$</span>: location of mass center</li><li><span>$i_{22}$</span>: mass moment of inertia about axis 2</li><li><span>$i_{33}$</span>: mass moment of inertia about axis 3</li><li><span>$i_{23}$</span>: product of inertia</li></ul><p>We assume that our beam has a constant cross section with the following properties:</p><ul><li>1 inch width</li><li>0.063 inch height</li><li>1.06 x 10^7 lb/in^2 elastic modulus</li><li>0.325 Poisson&#39;s ratio</li><li>2.51 x 10^-4 lb sec^2/in^4 density</li></ul><p>We also assume the following shear and torsion correction factors:</p><ul><li>ky = 1.2000001839588001</li><li>kz = 14.625127919304001</li><li>kt = 65.85255016982444</li></ul><pre><code class="language-julia"># cross section
w = 1 # inch
h = 0.063 # inch

# material properties
E = 1.06e7 # lb/in^2
ν = 0.325
ρ = 2.51e-4 # lb sec^2/in^4

# shear and torsion correction factors
ky = 1.2000001839588001
kz = 14.625127919304001
kt = 65.85255016982444

A = h*w
Iyy = w*h^3/12
Izz = w^3*h/12
J = Iyy + Izz

# apply corrections
Ay = A/ky
Az = A/kz
Jx = J/kt

G = E/(2*(1+ν))

compliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*Jx), 1/(E*Iyy), 1/(E*Izz)]), nelem)

mass = fill(Diagonal([ρ*A, ρ*A, ρ*A, ρ*J, ρ*Iyy, ρ*Izz]), nelem)</code></pre><p>Our case is simple enough that we can analytically calculate most values for the compliance and mass matrices, but this is not generally the case.  For more complex geometries/structures it may be necessary to use a cross-sectional property solver such as PreComp or VABS.</p><p>Also note that any row/column of the stiffness and/or compliance matrix which is zero will be interpreted as infinitely stiff in that degree of freedom.  This corresponds to a row/column of zeros in the compliance matrix.</p><p>We are now ready to put together our assembly.</p><pre><code class="language-julia">assembly = Assembly(points, start, stop, compliance=compliance, mass=mass, frames=Cab, lengths=lengths, midpoints=midpoints)</code></pre><p>At this point this is probably a good time to check that the geometry of our assembly is correct.  We can do this by visualizing the geometry in ParaView.  We can use the <code>write_vtk</code> function to do this.  Note that in order to visualize the generated file yourself you will need to install ParaView separately.</p><pre><code class="language-julia">write_vtk(&quot;swept-tip&quot;, assembly)</code></pre><p><img src="../swept-tip.png" alt/></p><h2 id="Defining-Distributed-Loads"><a class="docs-heading-anchor" href="#Defining-Distributed-Loads">Defining Distributed Loads</a><a id="Defining-Distributed-Loads-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Distributed-Loads" title="Permalink"></a></h2><p>We won&#39;t be applying distributed loads to our model, but will demonstrate how to do so.</p><p>Distributed loads are defined by using the constructor <code>DistributedLoads</code>.  One instance of <code>DistributedLoads</code> must be created for every beam element on which the distributed load is applied.  These instances of <code>DistributedLoads</code> are then stored in a dictionary in which they are accessed by their beam element index.  </p><p>To define a <code>DistributedLoad</code> the assembly, element number, and distributed load functions must be passed to <code>distributed_loads</code>.  Possible distributed load functions are:</p><ul><li><code>fx</code>: Distributed non-follower force on beam element in x-direction</li><li><code>fy</code>: Distributed non-follower force on beam element in y-direction</li><li><code>fz</code>: Distributed non-follower force on beam element in z-direction</li><li><code>mx</code>: Distributed non-follower moment on beam element in x-direction</li><li><code>my</code>: Distributed non-follower moment on beam element in y-direction</li><li><code>mz</code>: Distributed non-follower moment on beam element in z-direction</li><li><code>fx_follower</code>: Distributed follower force on beam element in x-direction</li><li><code>fy_follower</code>: Distributed follower force on beam element in y-direction</li><li><code>fz_follower</code>: Distributed follower force on beam element in z-direction</li><li><code>mx_follower</code>: Distributed follower moment on beam element in x-direction</li><li><code>my_follower</code>: Distributed follower moment on beam element in y-direction</li><li><code>mz_follower</code>: Distributed follower moment on beam element in z-direction</li></ul><p>By default these functions are specified as functions of the arbitrary coordinate <code>s</code> (<span>$f(s)$</span>), however, if more than one time step is used in the simulation these functions are specified as a function of the arbitrary coordinate <code>s</code> and time <code>t</code> (<span>$f(s,t)$</span>).</p><p>One can specify the s-coordinate at the start and end of the beam element using the keyword arguments <code>s1</code> and <code>s2</code>.</p><p>For example, the following code applies a uniform 10 pound distributed load in the global z-direction on all beam elements:</p><pre><code class="language-julia">distributed_loads = Dict()
for ielem in 1:nelem
    distributed_loads[ielem] = DistributedLoads(assembly, ielem; fz = (s) -&gt; 10)
end</code></pre><p>To instead make this a follower force (a force that rotates with the structure) we would use the following code:</p><pre><code class="language-julia">distributed_loads = Dict()
for ielem in 1:nelem
    distributed_loads[ielem] = DistributedLoads(assembly, ielem; fz_follower = (s) -&gt; 10)
end</code></pre><p>The units are arbitrary, but must be consistent with the units used when constructing <code>assembly</code>.  Also note that both non-follower and follower forces may exist simultaneously.</p><p>If we wanted to define the same follower force for a simulation with multiple time steps we would also need to provide temporal data.  Assuming a step size of 0.01 seconds and 101 steps in the simulation (including the step to find the solution at time t=0.0) this would be done as follows:</p><pre><code class="language-julia">dt = 0.01
nstep = 101
distributed_loads_multistep = Dict()
for ielem in 1:nelem
    distributed_loads_multistep[ielem] = DistributedLoads(assembly, ielem, dt; nstep=101, fz = (s,t) -&gt; 10)
end</code></pre><p>It is worth noting that the distributed loads are integrated over each element when they are created using 4-point Gauss-Legendre quadrature.  If more control over the integration is desired one may specify a custom integration method as described in the documentation for <code>DistributedLoads</code>.</p><h3 id="Defining-Prescribed-Conditions"><a class="docs-heading-anchor" href="#Defining-Prescribed-Conditions">Defining Prescribed Conditions</a><a id="Defining-Prescribed-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Prescribed-Conditions" title="Permalink"></a></h3><p>Whereas distributed loads are applied to beam elements, prescribed conditions are forces and/or displacement boundary conditions applied to points. One instance of <code>PrescribedConditions</code> must be created for every point on which prescribed conditions are applied.  These instances of <code>PrescribedConditions</code> are then stored in a dictionary in which they are accessed by their point index.  </p><p>PrescribedConditions may be either specified as a constant or as a function of time.  Possible prescribed conditions include:</p><ul><li><code>ux</code>: Prescribed x-direction displacement of the point</li><li><code>uy</code>: Prescribed y-direction displacement of the point</li><li><code>uz</code>: Prescribed z-direction displacement of the point</li><li><code>theta_x</code>: Prescribed first Wiener-Milenkovic parameter of the point</li><li><code>theta_y</code>: Prescribed second Wiener-Milenkovic parameter of the point</li><li><code>theta_z</code>: Prescribed third Wiener-Milenkovic parameter of the point</li><li><code>Fx</code>: Prescribed force in x-direction applied on the point</li><li><code>Fy</code>: Prescribed force in y-direction applied on the point</li><li><code>Fz</code>: Prescribed force in z-direction applied on the point</li><li><code>Mx</code>: Prescribed moment about x-axis applied on the point</li><li><code>My</code>: Prescribed moment about y-axis applied on the point</li><li><code>Mz</code>: Prescribed moment about z-axis applied on the point</li><li><code>Fx_follower</code>: Prescribed follower force in x-direction applied on the point</li><li><code>Fy_follower</code>: Prescribed follower force in y-direction applied on the point</li><li><code>Fz_follower</code>: Prescribed follower force in z-direction applied on the point</li><li><code>Mx_follower</code>: Prescribed follower moment about x-axis applied on the point</li><li><code>My_follower</code>: Prescribed follower moment about y-axis applied on the point</li><li><code>Mz_follower</code>: Prescribed follower moment about z-axis applied on the point</li></ul><p>One can apply both force and displacement boundary conditions to the same point, but one cannot specify a force and displacement condition at the same point corresponding to the same degree of freedom.  If this is requested an error will result.</p><p>Here we create a fixed boundary condition on the left side of the beam.</p><pre><code class="language-julia"># create dictionary of prescribed conditions
prescribed_conditions = Dict(
    # root section is fixed
    1 =&gt; PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)
    )</code></pre><p>To do the same for a simulation with multiple time steps:</p><pre><code class="language-julia"># create dictionary of prescribed conditions
dt = 0.01
nstep = 101
prescribed_conditions_multistep = Dict(
    # root section is fixed
    1 =&gt; PrescribedConditions(dt; nstep=nstep, ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)
    )</code></pre><p>We could have also specified <code>ux</code>, <code>uy</code>, <code>uz</code>, <code>theta_x</code>, <code>theta_y</code>, and <code>theta_z</code> as functions of time.</p><h3 id="Pre-Initializing-Memory-for-an-Analysis"><a class="docs-heading-anchor" href="#Pre-Initializing-Memory-for-an-Analysis">Pre-Initializing Memory for an Analysis</a><a id="Pre-Initializing-Memory-for-an-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-Initializing-Memory-for-an-Analysis" title="Permalink"></a></h3><p>At this point we have everything we need to perform an analysis.  However, since we will be performing multiple analyses using the same assembly we can save computational time be preallocating memory for the analysis.  This can be done by constructing an object of type <code>System</code>.  The constructor for this object requires that we provide the assembly, a list of points upon which point conditions are applied, and a flag indicating whether the system is static.</p><pre><code class="language-julia">prescribed_points = [1, nelem+1]
static = false
system = System(assembly, prescribed_points, static)</code></pre><h3 id="Performing-an-Analysis"><a class="docs-heading-anchor" href="#Performing-an-Analysis">Performing an Analysis</a><a id="Performing-an-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Performing-an-Analysis" title="Permalink"></a></h3><p>We&#39;re now ready to perform our steady state analyses.  This can be done by calling <code>steady_state_analysis</code> with the pre-allocated system storage, assembly, angular velocity, and the prescribed point conditions.  We can also perform a linear analysis instead of a nonlinear analysis by using the <code>linear</code> keyword argument.</p><p>After each analysis we&#39;ll also construct an object of type AssemblyState so that we can save the results of each analysis prior to re-using the pre-allocated memory for the next analysis.</p><pre><code class="language-julia">rpm = 0:25:750

linear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))
for i = 1:length(rpm)

    # global frame rotation
    w0 = [0, 0, rpm[i]*(2*pi)/60]

    # perform linear steady state analysis
    _, converged = steady_state_analysis!(system, assembly,
        angular_velocity = w0,
        prescribed_conditions = prescribed_conditions,
        linear = true)

    linear_states[i] = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)

end

reset_state!(system)

nonlinear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))
for i = 1:length(rpm)

   # global frame rotation
   w0 = [0, 0, rpm[i]*(2*pi)/60]

    # perform nonlinear steady state analysis
    _, converged = steady_state_analysis!(system, assembly,
        angular_velocity = w0,
        prescribed_conditions = prescribed_conditions)

     nonlinear_states[i] = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)

end</code></pre><h3 id="Post-Processing"><a class="docs-heading-anchor" href="#Post-Processing">Post Processing</a><a id="Post-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#Post-Processing" title="Permalink"></a></h3><p>We can access the fields in each instance of <code>AssemblyState</code> in order to plot various quantities of interest.  This object stores an array of objects of type <code>PointState</code> in the field <code>points</code> and an array of objects of type <code>ElementState</code> in the field <code>elements</code>.  </p><p>The fields of <code>PointState</code> are the following:</p><ul><li><code>u</code>: displacement</li><li><code>theta</code>: angular displacement</li><li><code>F</code>: externally applied forces</li><li><code>M</code>: externally applied moments</li></ul><p>The fields of <code>ElementState</code> are the following:</p><ul><li><code>u</code>: displacement</li><li><code>theta</code>: angular displacement</li><li><code>F</code>: resultant forces</li><li><code>M</code>: resultant moments</li><li><code>P</code>: linear momenta</li><li><code>H</code>: angular momenta</li></ul><p>To demonstrate how these fields can be accessed we will now plot the root moment and tip deflections.</p><pre><code class="language-julia">using Plots
pyplot()

# root moment
plot(
    xlim = (0, 760),
    xticks = 0:100:750,
    xlabel = &quot;Angular Speed (RPM)&quot;,
    yticks = 0.0:2:12,
    ylabel = &quot;\$M_z\$ at the root (lb-in)&quot;,
    grid = false,
    overwrite_figure=false
    )
Mz_nl = [-nonlinear_states[i].points[1].M[3] for i = 1:length(rpm)]
Mz_l = [-linear_states[i].points[1].M[3] for i = 1:length(rpm)]
plot!(rpm, Mz_nl, label=&quot;Nonlinear&quot;)
plot!(rpm, Mz_l, label=&quot;Linear&quot;)


# x tip deflection
plot(
    xlim = (0, 760),
    xticks = 0:100:750,
    xlabel = &quot;Angular Speed (RPM)&quot;,
    ylim = (-0.002, 0.074),
    yticks = 0.0:0.01:0.07,
    ylabel = &quot;\$u_x\$ at the tip (in)&quot;,
    grid = false,
    overwrite_figure=false
    )
ux_nl = [nonlinear_states[i].points[end].u[1] for i = 1:length(rpm)]
ux_l = [linear_states[i].points[end].u[1] for i = 1:length(rpm)]
plot!(rpm, ux_nl, label=&quot;Nonlinear&quot;)
plot!(rpm, ux_l, label=&quot;Linear&quot;)


# y tip deflection
plot(
    xlim = (0, 760),
    xticks = 0:100:750,
    xlabel = &quot;Angular Speed (RPM)&quot;,
    ylim = (-0.01, 0.27),
    yticks = 0.0:0.05:0.25,
    ylabel = &quot;\$u_y\$ at the tip (in)&quot;,
    grid = false,
    overwrite_figure=false
    )
uy_nl = [nonlinear_states[i].points[end].u[2] for i = 1:length(rpm)]
uy_l = [linear_states[i].points[end].u[2] for i = 1:length(rpm)]
plot!(rpm, uy_nl, label=&quot;Nonlinear&quot;)
plot!(rpm, uy_l, label=&quot;Linear&quot;)


# rotation of the tip
plot(
    xlim = (0, 760),
    xticks = 0:100:750,
    xlabel = &quot;Angular Speed (RPM)&quot;,
    ylabel = &quot;\$θ_z\$ at the tip&quot;,
    grid = false,
    overwrite_figure=false
    )
theta_z_nl = [4*atan(nonlinear_states[i].points[end].theta[3]/4) for i = 1:length(rpm)]
theta_z_l = [4*atan(linear_states[i].points[end].theta[3]/4) for i = 1:length(rpm)]

plot!(rpm, theta_z_nl, label=&quot;Nonlinear&quot;)
plot!(rpm, theta_z_l, label=&quot;Linear&quot;)</code></pre><p><img src="../rotating-beam-Mz.svg" alt/> <img src="../rotating-beam-ux.svg" alt/> <img src="../rotating-beam-uy.svg" alt/> <img src="../rotating-beam-theta_z.svg" alt/></p><p>We can also perform an eigenvalue analysis for the same problem. The setup is similar to that for a steady state simulation.</p><p>In the following block of code we define a function that performs an eigenanalysis for any sweep angle and revolution rate.  The main difference between performing a steady state analysis versus an eigenvalue analysis is the use of the <code>eigenvalue_analysis</code> function.  This function returns the modified system, the eigenvalues, a matrix of eigenvectors, and a convergence flag.</p><pre><code class="language-julia">eigenanalysis = function(sweep, rpm, nev)

    # straight section of the beam
    L_b1 = 31.5 # inch
    r_b1 = [2.5, 0, 0]
    nelem_b1 = 20
    lengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1)

    # swept section of the beam
    L_b2 = 6 # inch
    r_b2 = [34, 0, 0]
    nelem_b2 = 20
    cs, ss = cos(sweep), sin(sweep)
    frame_b2 = [cs ss 0; -ss cs 0; 0 0 1]
    lengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2, frame=frame_b2)

    # combine elements and points into one array
    nelem = nelem_b1 + nelem_b2
    points = vcat(xp_b1, xp_b2[2:end])
    start = 1:nelem_b1 + nelem_b2
    stop = 2:nelem_b1 + nelem_b2 + 1
    lengths = vcat(lengths_b1, lengths_b2)
    midpoints = vcat(xm_b1, xm_b2)
    Cab = vcat(Cab_b1, Cab_b2)

    # cross section
    w = 1 # inch
    h = 0.063 # inch

    # material properties
    E = 1.06e7 # lb/in^2
    ν = 0.325
    ρ = 2.51e-4 # lb sec^2/in^4

    # shear and torsion correction factors
    ky = 1.2000001839588001
    kz = 14.625127919304001
    kt = 65.85255016982444

    A = h*w
    Iyy = w*h^3/12
    Izz = w^3*h/12
    J = Iyy + Izz

    # apply corrections
    Ay = A/ky
    Az = A/kz
    Jx = J/kt

    G = E/(2*(1+ν))

    compliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*Jx), 1/(E*Iyy), 1/(E*Izz)]), nelem)

    mass = fill(Diagonal([ρ*A, ρ*A, ρ*A, ρ*J, ρ*Iyy, ρ*Izz]), nelem)

    # create assembly
    assembly = Assembly(points, start, stop, compliance=compliance, mass=mass, frames=Cab, lengths=lengths, midpoints=midpoints)

    prescribed_conditions = Dict(
        # root section is fixed
        1 =&gt; PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)
        )

    w0 = [0, 0, rpm*(2*pi)/60]

    # eigenvalues and right eigenvector matrix
    system, λ, V, converged = eigenvalue_analysis(assembly,
        angular_velocity = w0,
        prescribed_conditions = prescribed_conditions,
        nev=nev)

    # process state
    state = AssemblyState(system, assembly; prescribed_conditions=prescribed_conditions)

    # process eigenstates
    eigenstates = [AssemblyState(system, assembly, V;
        prescribed_conditions=prescribed_conditions) for k = 1:nev]

    # corresponding left eigenvector matrix
    U = left_eigenvectors(system, λ, V)

    # save system mass matrix
    M = copy(system.M)

    return state, eigenstates, λ, U, M, V, converged
end</code></pre><p>Beyond simply calculating eigenvalues and (right) eigenvectors, we performed a couple additional post-processing steps in this function.  First, we constructed objects of type <code>AssemblyState</code>, which can help to interpret eigenvector data.  Second, we calculated a left eigenvector matrix which satisfies the following M-orthonormal relationship:</p><div>\[UMV = I\]</div><p>Finally, we saved the mass matrix so that we can use it to establish mode-correlations.</p><p>We&#39;ll now perform eigenvalue analyses on a variety of combinations of sweep angles and revolution rates to see how changing these parameters affects the natural frequencies of the structure.</p><pre><code class="language-julia">sweep = (0:2.5:45) * pi/180
rpm = [0, 500, 750]
nev = 30

state = Matrix{AssemblyState{Float64}}(undef, length(sweep), length(rpm))
eigenstates = Matrix{Vector{AssemblyState{ComplexF64}}}(undef, length(sweep), length(rpm))
λ = Matrix{Vector{ComplexF64}}(undef, length(sweep), length(rpm))
U = Matrix{Matrix{ComplexF64}}(undef, length(sweep), length(rpm))
M = Matrix{Matrix{ComplexF64}}(undef, length(sweep), length(rpm))
V = Matrix{Matrix{ComplexF64}}(undef, length(sweep), length(rpm))
for j = 1:length(rpm)
    for i = 1:length(sweep)
        state[i,j], eigenstates[i,j], λ[i,j], U[i,j], M[i,j], V[i,j], converged = eigenanalysis(sweep[i], rpm[j], nev)
    end
end

frequency = [[imag(λ[i,j][k])/(2*pi) for i = 1:length(sweep), j=1:length(rpm)] for k = 2:2:nev]</code></pre><p>To identify each of the modes, we can visualize them using ParaView using the <code>write_vtk</code> function. If we visualize the first mode for the 45 degree sweep/750 RPM case, we can see that it corresponds to the first bending mode.</p><pre><code class="language-julia">write_vtk(&quot;rotating-beam-45d-750rpm-bending-mode-1&quot;, assembly, state[end,end], λ[end,end][1],
    eigenstates[end,end][1], mode_scaling=100.0)</code></pre><p>The same process may be used to identify all the other modes.</p><p><img src="../rotating-beam.gif" alt/></p><p>In addition to identifying modes manually, we can also correlate modes by using the M-orthonormal relationship between the left and right eigenvectors.  To do so, we&#39;ll use the function <code>correlate_eigenmodes</code>.  If modes are properly ordered, the correlation matrix (defined as <span>$U_{i-1}M_{i}V_{i}$</span>) passed to <code>correlate_eigenmodes</code> will be diagonally dominant, otherwise <code>correlate_eigenmodes</code> will find a row/column permutation that will make the matrix diagonally dominant, if possible.  Here we&#39;ll do this for this our range of parameters.</p><pre><code class="language-julia">U_p = copy(U[1,1])
for j = 1:length(rpm)
    for i = 1:length(sweep)
        # construct correlation matrix
        C = U_p*M[i,j]*V[i,j]

        # correlate eigenmodes
        perm, corruption = correlate_eigenmodes(C)

        # fix ordering of modes
        eigenstates[i,j] = eigenstates[i,j][perm]
        λ[i,j] = λ[i,j][perm]
        U[i,j] = U[i,j][perm,:]
        V[i,j] = V[i,j][:,perm]

        # update previous left eigenvector matrix
        U_p .= U[i,j]
    end
    # update previous left eigenvector matrix
    U_p .= U[1,j]
end

frequency = [[imag(λ[i,j][k])/(2*pi) for i = 1:length(sweep), j=1:length(rpm)] for k = 2:2:nev]</code></pre><p>In this case these eigenmode correlations work, but remember that large changes in the underlying parameters (or just drastic changes in the eigenvectors themselves due to a small perturbation) can cause these automatic eigenmode correlations to fail.</p><p>To check our correlations, we can plot the frequency of the different eigenmodes against those found by Epps and Chandra in &quot;The Natural Frequencies of Rotating Composite Beams With Tip Sweep&quot;.</p><pre><code class="language-julia">names = [&quot;First Bending Mode&quot;, &quot;Second Bending Mode&quot;, &quot;Third Bending Mode&quot;]
indices = [1, 2, 4]

experiment_rpm = [0, 500, 750]
experiment_sweep = [0, 15, 30, 45]
experiment_frequencies = [
    [1.4 1.8 1.7 1.6;
     10.2 10.1 10.2 10.2;
     14.8 14.4 14.9 14.7],
    [10.3 10.2 10.4 10.4;
     25.2 25.2 23.7 21.6;
     36.1 34.8 30.7 26.1],
    [27.7 27.2 26.6 24.8;
     47.0 44.4 39.3 35.1;
     62.9 55.9 48.6 44.8]
]

plot!([NaN, NaN], [NaN, NaN], color=:black, label=&quot;GEBT&quot;)
scatter!([NaN, NaN], [NaN, NaN], color=:black, label=&quot;Experiment (Epps and Chandra)&quot;)

for k = 1:length(indices)
    plot(
        title = names[k],
        xticks = 0:15:45,
        xlabel = &quot;Sweep Angle (degrees)&quot;,
        ylim = (0, Inf),
        ylabel = &quot;Frequency (Hz)&quot;,
        grid = false,
        overwrite_figure=false
        )

    for j = length(rpm):-1:1
        plot!(sweep*180/pi, frequency[indices[k]][:,j], label=&quot;$(rpm[j]) RPM&quot;, color=j)
        scatter!(experiment_sweep, experiment_frequencies[k][j,:],
            label=&quot;&quot;, color=j)
    end

    plot!(show=true)
end

names = [&quot;1T/5B&quot;, &quot;5B/1T&quot;, &quot;4B/1T&quot;]
indices = [5, 7, 6]

experiment_frequencies = [
    132.7 147.3 166.2 162.0
    106.6 120.1 122.6 117.7;
    95.4 87.5 83.7 78.8;
]

plot(
    title = &quot;Coupled Torsion-Bending Modes at 750 RPM&quot;,
    xticks = 0:15:45,
    xlabel = &quot;Sweep Angle (degrees)&quot;,
    ylim = (0, Inf),
    ylabel = &quot;Frequency (Hz)&quot;,
    grid = false,
    overwrite_figure=false
    )

plot!([NaN, NaN], [NaN, NaN], color=:black, label=&quot;GEBT&quot;)
scatter!([NaN, NaN], [NaN, NaN], color=:black, label=&quot;Experiment (Epps and Chandra)&quot;)

for k = 1:length(indices)
    plot!(sweep*180/pi, frequency[indices[k]][:,end], label=names[k], color=k)
    scatter!(experiment_sweep, experiment_frequencies[k,:],
        label=&quot;&quot;, color=k)
end

plot!(show=true)</code></pre><pre class="documenter-example-output">sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.
sys:1: UserWarning: FixedFormatter should only be used together with FixedLocator
sys:1: MatplotlibDeprecationWarning: Case-insensitive properties were deprecated in 3.3 and support will be removed two minor releases later
sys:1: MatplotlibDeprecationWarning: Passing the fontdict parameter of _set_ticklabels() positionally is deprecated since Matplotlib 3.3; the parameter will become keyword-only two minor releases later.</pre><p><img src="../rotating-beam-frequencies-1.svg" alt/> <img src="../rotating-beam-frequencies-2.svg" alt/> <img src="../rotating-beam-frequencies-3.svg" alt/> <img src="../rotating-beam-frequencies-4.svg" alt/></p><p>As you can see, the frequency results from the eigenmode analysis in this package compare well with experimental results.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 4 September 2020 21:19">Friday 4 September 2020</span>. Using Julia version 1.5.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
