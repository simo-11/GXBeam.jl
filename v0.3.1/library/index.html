<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · GXBeam.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GXBeam.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guide/">Getting Started</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../diffeq/">Using GXBeam with DifferentialEquations.jl</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Public-API"><span>Public API</span></a></li><li><a class="tocitem" href="#Private-API"><span>Private API</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><ul><li><a href="#Library">Library</a></li><li class="no-marker"><ul><li><a href="#Public-API">Public API</a></li><li class="no-marker"><ul><li><a href="#Creating-an-Assembly">Creating an Assembly</a></li><li><a href="#Defining-Point-Masses">Defining Point Masses</a></li><li><a href="#Defining-Distributed-Loads">Defining Distributed Loads</a></li><li><a href="#Defining-Prescribed-Conditions">Defining Prescribed Conditions</a></li><li><a href="#Pre-Initializing-Memory-for-an-Analysis">Pre-Initializing Memory for an Analysis</a></li><li><a href="#Performing-an-Analysis">Performing an Analysis</a></li><li><a href="#Post-Processing">Post-Processing</a></li></ul></li><li><a href="#Private-API">Private API</a></li><li class="no-marker"><ul><li><a href="#Math">Math</a></li><li><a href="#Points">Points</a></li><li><a href="#Elements">Elements</a></li><li><a href="#Loads">Loads</a></li><li><a href="#System">System</a></li></ul></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h2><h3 id="Creating-an-Assembly"><a class="docs-heading-anchor" href="#Creating-an-Assembly">Creating an Assembly</a><a id="Creating-an-Assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-an-Assembly" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.curve_length" href="#GXBeam.curve_length"><code>GXBeam.curve_length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">curve_length(start, stop, curvature)</code></pre><p>Calculate the length of a curve given its endpoints and its curvature vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/assembly.jl#L179-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.discretize_beam" href="#GXBeam.discretize_beam"><code>GXBeam.discretize_beam</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">discretize_beam(L, start, discretization; frame, curvature)</code></pre><p>Discretize a beam of length <code>L</code> located at <code>start</code> according to the discretization provided  in <code>discretization</code></p><p>Return the lengths, endpoints, midpoints, and reference frame of the beam elements.</p><p><strong>Arguments</strong></p><ul><li><code>L</code>: Beam length</li><li><code>start</code>: Beam starting point</li><li><code>discretization</code>: Number of beam elements, or the normalized endpoints of each beam       element, with values ranging from 0 to 1.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>frame</code>: Reference frame at the start of the beam element, represented by a 3x3       transformation matrix from the undeformed local frame to the body frame.</li><li><code>curvature</code>: curvature vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/assembly.jl#L85-L103">source</a></section><section><div><pre><code class="nohighlight hljs">discretize_beam(start, stop, discretization; frame, curvature)</code></pre><p>Discretize a beam from <code>start</code> to <code>stop</code> according to the discretization provided in  <code>discretization</code>.</p><p>Return the lengths, endpoints, midpoints, and reference frame of the beam elements.</p><p><strong>Arguments</strong></p><ul><li><code>start</code>: Beam starting point</li><li><code>stop</code>: Beam ending point</li><li><code>discretization</code>: Number of beam elements, or the normalized endpoints of each beam       element, with values ranging from 0 to 1.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>frame</code>: Reference frame at the start of the beam element, represented by a 3x3      transformation matrix from the undeformed local frame to the body frame.</li><li><code>curvature</code>: curvature vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/assembly.jl#L141-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.Assembly-Tuple{Any, Any, Any}" href="#GXBeam.Assembly-Tuple{Any, Any, Any}"><code>GXBeam.Assembly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Assembly(points, start, stop; kwargs...)</code></pre><p>Construct an assembly of connected nonlinear beam elements for analysis.  Beam lengths and midpoints may be manually specified in case beam elements are curved rather than straight.</p><p><strong>Arguments</strong></p><ul><li><code>points</code>: Array of all beam element endpoints</li><li><code>start</code>: Array containing point indices where each beam element starts</li><li><code>stop</code>: Array containing point indices where each beam element stops</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>stiffness</code>: Array of (6 x 6) stiffness matrices for each beam element,       acts as an alternative to providing <code>compliance</code></li><li><code>compliance</code>: Array of (6 x 6) compliance matrices for each beam element,       defaults to <code>zeros(6,6)</code> for each beam element</li><li><code>mass</code>: Array of (6 x 6) mass matrices for each beam element,       defaults to <code>zeros(6,6)</code> for each beam element</li><li><code>frames</code>: Array of (3 x 3) tranformation matrices for each beam element.      Transforms from the local undeformed beam frame to the global frame) and defaults      to the identity matrix for each beam element</li><li><code>lengths</code>: Array containing the length of each beam, defaults to the distance between       beam endpoints</li><li><code>midpoints</code>: Array containing the midpoint of each beam element, defaults to the average       of the beam element endpoints</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/assembly.jl#L22-L48">source</a></section></article><h3 id="Defining-Point-Masses"><a class="docs-heading-anchor" href="#Defining-Point-Masses">Defining Point Masses</a><a id="Defining-Point-Masses-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Point-Masses" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.PointMass" href="#GXBeam.PointMass"><code>GXBeam.PointMass</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PointMass{T}</code></pre><p>Type which contains the aggregated inertial properties of one or more point masses which  are rigidly attached to the center of an element.</p><p><strong>Fields:</strong></p><ul><li><code>mass</code>: Mass matrix corresponding to the point masses.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/loads.jl#L405-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.PointMass-Tuple{Any, Any, Any}" href="#GXBeam.PointMass-Tuple{Any, Any, Any}"><code>GXBeam.PointMass</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PointMass(m, p, I)</code></pre><p>Define a point mass given its mass <code>m</code>, offset <code>p</code>, and inertia matrix <code>I</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/loads.jl#L430-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.combine_masses" href="#GXBeam.combine_masses"><code>GXBeam.combine_masses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">combine_masses(masses)</code></pre><p>Combine the point masses in the iterable collection <code>masses</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/loads.jl#L437-L441">source</a></section></article><h3 id="Defining-Distributed-Loads"><a class="docs-heading-anchor" href="#Defining-Distributed-Loads">Defining Distributed Loads</a><a id="Defining-Distributed-Loads-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Distributed-Loads" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.DistributedLoads" href="#GXBeam.DistributedLoads"><code>GXBeam.DistributedLoads</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DistributedLoads{T}</code></pre><p>Type which contains pre-integrated distributed forces and moments applied to a beam element.</p><p><strong>Fields</strong></p><ul><li>f1: Integrated non-follower distributed force corresponding to the start of the beam element.</li><li>f2: Integrated non-follower distributed force corresponding to the end of the beam element.</li><li>m1: Integrated non-follower distributed moment corresponding to the start of the beam element.</li><li>m2: Integrated non-follower distributed moment corresponding to the end of the beam element.</li><li>f1_follower: Integrated follower distributed force corresponding to the start of the beam element.</li><li>f2_follower: Integrated follower distributed force corresponding to the end of the beam element.</li><li>m1_follower: Integrated follower distributed moment corresponding to the start of the beam element.</li><li>m2_follower: Integrated follower distributed moment corresponding to the end of the beam element.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/loads.jl#L164-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.DistributedLoads-Tuple{Any, Any}" href="#GXBeam.DistributedLoads-Tuple{Any, Any}"><code>GXBeam.DistributedLoads</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DistributedLoads(assembly, ielem; kwargs...)</code></pre><p>Pre-integrate distributed loads on a beam element for use in an analysis.</p><p><strong>Arguments</strong></p><ul><li><code>assembly</code>: Beam element assembly (of type <a href="#GXBeam.Assembly"><code>Assembly</code></a>)</li><li><code>ielem</code>: Beam element index</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>s1 = 0.0</code>: Start of the beam element (used solely for integrating the distributed loads)</li><li><code>s2 = 1.0</code>: End of the beam element (used solely for integrating the distributed loads)</li><li><code>method = (f, s1, s2) -&gt; gauss_quadrature(f, s1, s2)</code>: Method which integrates function  <code>f</code> from <code>s1</code> to <code>s2</code>. Defaults to the Gauss-Legendre quadrature with 4 points   on each element.</li><li><code>fx = (s) -&gt; 0.0</code>: Distributed x-direction force</li><li><code>fy = (s) -&gt; 0.0</code>: Distributed y-direction force</li><li><code>fz = (s) -&gt; 0.0</code>: Distributed z-direction force</li><li><code>mx = (s) -&gt; 0.0</code>: Distributed x-direction moment</li><li><code>my = (s) -&gt; 0.0</code>: Distributed y-direction moment</li><li><code>mz = (s) -&gt; 0.0</code>: Distributed z-direction moment</li><li><code>fx_follower = (s) -&gt; 0.0</code>: Distributed x-direction follower force</li><li><code>fy_follower = (s) -&gt; 0.0</code>: Distributed y-direction follower force</li><li><code>fz_follower = (s) -&gt; 0.0</code>: Distributed z-direction follower force</li><li><code>mx_follower = (s) -&gt; 0.0</code>: Distributed x-direction follower moment</li><li><code>my_follower = (s) -&gt; 0.0</code>: Distributed y-direction follower moment</li><li><code>mz_follower = (s) -&gt; 0.0</code>: Distributed z-direction follower moment</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/loads.jl#L199-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.combine_loads" href="#GXBeam.combine_loads"><code>GXBeam.combine_loads</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">combine_loads(loads)</code></pre><p>Combine the distributed loads in the iterable collection <code>loads</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/loads.jl#L378-L382">source</a></section></article><h3 id="Defining-Prescribed-Conditions"><a class="docs-heading-anchor" href="#Defining-Prescribed-Conditions">Defining Prescribed Conditions</a><a id="Defining-Prescribed-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Prescribed-Conditions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.PrescribedConditions" href="#GXBeam.PrescribedConditions"><code>GXBeam.PrescribedConditions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrescribedConditions{T}</code></pre><p>Type which contains the forces, moments, displacements, and/or rotations prescribed at a point.</p><p><strong>Fields:</strong></p><ul><li><code>isforce</code>: Flag for each degree of freedom indicating whether forces/moments or   displacements are prescribed </li><li><code>value</code>: Magnitude of the prescribed force/moment and/or displacement associated   with each degree of freedom </li><li><code>follower</code>: Magnitude of the follower force/moment associated with each degree of   freedom (if applicable)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/loads.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.PrescribedConditions-Tuple{}" href="#GXBeam.PrescribedConditions-Tuple{}"><code>GXBeam.PrescribedConditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PrescribedConditions(t = 0.0; kwargs...)</code></pre><p>Return the prescribed conditions at a point at time <code>t</code>.</p><p>Individual prescribed conditions may be assigned as either a scalar parameter or as a function of time.</p><p>Prescribed Wiener-Milenkovic parameters must satisfy the following inequality: sqrt(theta<em>x^2 + theta</em>y^2 + theta_z^2) &lt;= 4.  Note that this restriction still allows all possible rotations to be represented.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>ux</code>: Prescribed x-displacement (in the body frame)</li><li><code>uy</code>: Prescribed y-displacement (in the body frame)</li><li><code>uz</code>: Prescribed z-displacement (in the body frame)</li><li><code>theta_x</code>: Prescribed first Wiener-Milenkovic parameter</li><li><code>theta_y</code>: Prescribed second Wiener-Milenkovic parameter</li><li><code>theta_z</code>: Prescribed third Wiener-Milenkovic parameter</li><li><code>Fx</code>: Prescribed x-direction force</li><li><code>Fy</code>: Prescribed y-direction force</li><li><code>Fz</code>: Prescribed z-direction force</li><li><code>Mx</code>: Prescribed x-direction moment</li><li><code>My</code>: Prescribed y-direction moment</li><li><code>Mz</code>: Prescribed z-direction moment</li><li><code>Fx_follower</code>: Prescribed x-direction follower force</li><li><code>Fy_follower</code>: Prescribed y-direction follower force</li><li><code>Fz_follower</code>: Prescribed z-direction follower force</li><li><code>Mx_follower</code>: Prescribed x-direction follower moment</li><li><code>My_follower</code>: Prescribed y-direction follower moment</li><li><code>Mz_follower</code>: Prescribed z-direction follower moment</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/loads.jl#L27-L58">source</a></section></article><h3 id="Pre-Initializing-Memory-for-an-Analysis"><a class="docs-heading-anchor" href="#Pre-Initializing-Memory-for-an-Analysis">Pre-Initializing Memory for an Analysis</a><a id="Pre-Initializing-Memory-for-an-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-Initializing-Memory-for-an-Analysis" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.System-Tuple{Any, Any}" href="#GXBeam.System-Tuple{Any, Any}"><code>GXBeam.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">System([TF=eltype(assembly),] assembly, static; kwargs...)</code></pre><p>Initialize an object of type <code>System</code> which stores the system state.</p><p><strong>Arguments:</strong></p><ul><li><code>TF:</code>(optional) Floating point type, defaults to the floating point type of <code>assembly</code></li><li><code>assembly</code>: Assembly of rigidly connected nonlinear beam elements</li><li><code>static</code>: Flag indicating whether the system corresponds to a static system.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>prescribed_points</code>: Point indices corresponding to the points whose equations  and state variables should be included in the system of equations.  By default,  all point indices are included in the system of equations.</li><li><code>force_scaling</code>: Factor used to scale system forces/moments internally.  If  not specified, a suitable default will be chosen based on the entries of the  compliance matrix.</li></ul><p>Note that points with prescribed conditions must be included in the system of equations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L48-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.system_state" href="#GXBeam.system_state"><code>GXBeam.system_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">system_state(system)</code></pre><p>Return a vector containing the state variables of <code>system</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L297-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.reset_state!" href="#GXBeam.reset_state!"><code>GXBeam.reset_state!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reset_state!(system)</code></pre><p>Reset the state variables in <code>system</code> (stored in <code>system.x</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L704-L708">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_state!" href="#GXBeam.set_state!"><code>GXBeam.set_state!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_state!([x,] system, prescribed_conditions; kwargs...)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) to the provided values. If values are not provided for a given keyword argument, then the state variables corresponding to the keyword argument are not updated.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>u_e</code>: Vector containing initial displacements (in the body frame) for each beam element.</li><li><code>theta_e</code>: Vector containing rotation variables (in the body frame) for each beam element.</li><li><code>F_e</code>: Vector containing resultant forces (in the deformed local beam element frame) for each beam element.</li><li><code>M_e</code>: Vector containing resultant moments (in the deformed local beam element frame) for each beam element.</li><li><code>V_e</code>: Vector containing linear velocity (in the deformed local beam element frame) for each beam element.</li><li><code>Ω_e</code>: Vector containing angular velocity (in the deformed local beam element frame) for each beam element.</li><li><code>u_p</code>: Vector containing initial displacements (in the body frame) for each point.</li><li><code>theta_p</code>: Vector containing rotation variables (in the body frame) for each point.</li><li><code>F_p</code>: Vector containing externally applied forces (in the body frame) for each point.</li><li><code>M_p</code>: Vector containing externally applied moments (in the body frame) for each point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L304-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_element_deflection!" href="#GXBeam.set_element_deflection!"><code>GXBeam.set_element_deflection!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_element_deflection!([x,] system, u_e, ielem)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the deflections of element <code>ielem</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L383-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_element_rotation!" href="#GXBeam.set_element_rotation!"><code>GXBeam.set_element_rotation!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_element_rotation!([x,] system, θ_b, ielem)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the rotations of element <code>ielem</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L405-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_element_forces!" href="#GXBeam.set_element_forces!"><code>GXBeam.set_element_forces!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_element_forces!([x,] system, F_e, ielem)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the resultant forces of element <code>ielem</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L427-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_element_moments!" href="#GXBeam.set_element_moments!"><code>GXBeam.set_element_moments!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_element_moments!([x,] system, u_e, ielem)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the resultant moments of element <code>ielem</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L450-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_element_linear_velocity!" href="#GXBeam.set_element_linear_velocity!"><code>GXBeam.set_element_linear_velocity!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_element_linear_velocity!([x,] system, V_e, ielem)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the linear velocity of element <code>ielem</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L473-L478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_element_angular_velocity!" href="#GXBeam.set_element_angular_velocity!"><code>GXBeam.set_element_angular_velocity!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>set<em>element</em>angular<em>velocity!([x,] system, Ω</em>e, ielem)</p><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the angular velocity of element <code>ielem</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L496-L501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_point_deflections!" href="#GXBeam.set_point_deflections!"><code>GXBeam.set_point_deflections!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_point_deflections!([x,] system, u_e, ipoint, prescribed_conditions)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the deflections (or externally applied forces) at point <code>ipoint</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L519-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_point_rotations!" href="#GXBeam.set_point_rotations!"><code>GXBeam.set_point_rotations!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_point_rotations!([x,] system, θ_e, ipoint, prescribed_conditions)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the rotations (or externally applied moments) at point <code>ipoint</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L565-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_point_forces!" href="#GXBeam.set_point_forces!"><code>GXBeam.set_point_forces!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_point_forces!([x,] system, F_p, ipoint, prescribed_conditions)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the external forces applied on point <code>ipoint</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L611-L616">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_point_moments!" href="#GXBeam.set_point_moments!"><code>GXBeam.set_point_moments!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_point_moments!([x,] system, M_p, ipoint, prescribed_conditions)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the external moments applied on point <code>ipoint</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L659-L664">source</a></section></article><h3 id="Performing-an-Analysis"><a class="docs-heading-anchor" href="#Performing-an-Analysis">Performing an Analysis</a><a id="Performing-an-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Performing-an-Analysis" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_analysis" href="#GXBeam.static_analysis"><code>GXBeam.static_analysis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_analysis(assembly; kwargs...)</code></pre><p>Perform a static analysis of the system of nonlinear beams contained in <code>assembly</code>. Return the resulting system and a flag indicating whether the iteration procedure converged.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}()</code>:      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and values of type      <a href="#GXBeam.PrescribedConditions"><code>PrescribedConditions</code></a> which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.</li><li><code>distributed_loads = Dict{Int,DistributedLoads{Float64}}()</code>: A dictionary      with keys corresponding to the elements to which distributed loads are      applied and values of type <a href="#GXBeam.DistributedLoads"><code>DistributedLoads</code></a> which describe      the distributed loads on those elements.  If time varying, this input may      be provided as a function of time.</li><li><code>point_masses = Dict{Int,PointMass{Float64}}()</code>: A dictionary with keys       corresponding to the beam elements to which point masses are attached and values       of type <a href="#GXBeam.PointMass"><code>PointMass</code></a> which contain the properties of the attached       point masses.  If time varying, this input may be provided as a function of time.</li><li><code>gravity = [0,0,0]</code>: Gravity vector.  If time varying, this input may be provided as a       function of time.</li><li><code>linear = false</code>: Set to <code>true</code> for a linear analysis</li><li><code>linearization_state</code>: Linearization state variables.  Defaults to zeros.</li><li><code>update_linearization_state</code>: Flag indicating whether to update the linearization state   variables for a linear analysis with the instantaneous state variables.</li><li><code>method = :newton</code>: Method (as defined in NLsolve) to solve nonlinear system of equations</li><li><code>linesearch = LineSearches.BackTracking(maxstep=1e6)</code>: Line search used to solve nonlinear       system of equations</li><li><code>ftol = 1e-9</code>: tolerance for solving nonlinear system of equations</li><li><code>iterations = 1000</code>: maximum iterations for solving the nonlinear system of equations</li><li><code>tvec = 0</code>: Time vector/value. May be used in conjunction with time varying      prescribed conditions and distributed loads to gradually increase      displacements/loads.</li><li><code>reset_state = true</code>: Flag indicating whether the state variables should be      reset prior to performing the analysis.  This keyword argument is only valid      for the pre-allocated version of this function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/analyses.jl#L1-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_analysis!" href="#GXBeam.static_analysis!"><code>GXBeam.static_analysis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_analysis!(system, assembly; kwargs...)</code></pre><p>Pre-allocated version of <code>static_analysis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/analyses.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_state_analysis" href="#GXBeam.steady_state_analysis"><code>GXBeam.steady_state_analysis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_state_analysis(assembly; kwargs...)</code></pre><p>Perform a steady-state analysis for the system of nonlinear beams contained in <code>assembly</code>.  Return the resulting system and a flag indicating whether the iteration procedure converged.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}()</code>:      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and values of type      <a href="#GXBeam.PrescribedConditions"><code>PrescribedConditions</code></a> which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.</li><li><code>distributed_loads = Dict{Int,DistributedLoads{Float64}}()</code>: A dictionary      with keys corresponding to the elements to which distributed loads are      applied and values of type <a href="#GXBeam.DistributedLoads"><code>DistributedLoads</code></a> which describe      the distributed loads on those elements.  If time varying, this input may      be provided as a function of time.</li><li><code>point_masses = Dict{Int,PointMass{Float64}}()</code>: A dictionary with keys       corresponding to the beam elements to which point masses are attached and values       of type <a href="#GXBeam.PointMass"><code>PointMass</code></a> which contain the properties of the attached       point masses.  If time varying, this input may be provided as a function of time.</li><li><code>gravity = [0,0,0]</code>: Gravity vector.  If time varying, this input may be provided as a       function of time.            </li><li><code>linear = false</code>: Set to <code>true</code> for a linear analysis</li><li><code>linearization_state</code>: Linearization state variables.  Defaults to zeros.</li><li><code>update_linearization_state</code>: Flag indicating whether to update the linearization state   variables for a linear analysis with the current state variables.</li><li><code>method = :newton</code>: Method (as defined in NLsolve) to solve nonlinear system of equations</li><li><code>linesearch = LineSearches.LineSearches.BackTracking(maxstep=1e6)</code>: Line search used to solve nonlinear system of equations</li><li><code>ftol = 1e-9</code>: tolerance for solving nonlinear system of equations</li><li><code>iterations = 1000</code>: maximum iterations for solving the nonlinear system of equations</li><li><code>origin = zeros(3)</code>: Global frame origin vector. If time varying, this input  may be provided as a function of time.</li><li><code>linear_velocity = zeros(3)</code>: Global frame linear velocity vector. If time  varying, this vector may be provided as a function of time.</li><li><code>angular_velocity = zeros(3)</code>: Global frame angular velocity vector. If time  varying, this vector may be provided as a function of time.</li><li><code>linear_acceleration = zeros(3)</code>: Global frame linear acceleration vector. If time  varying, this vector may be provided as a function of time.</li><li><code>angular_acceleration = zeros(3)</code>: Global frame angular acceleration vector. If time  varying, this vector may be provided as a function of time.</li><li><code>tvec = 0.0</code>: Time vector/value. May be used in conjunction with time varying  prescribed conditions, distributed loads, and global motion to gradually  increase displacements/loads.</li><li><code>reset_state = true</code>: Flag indicating whether the state variables should be  reset prior to performing the analysis.  This keyword argument is only valid  for the pre-allocated version of this function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/analyses.jl#L173-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_state_analysis!" href="#GXBeam.steady_state_analysis!"><code>GXBeam.steady_state_analysis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_state_analysis!(system, assembly; kwargs...)</code></pre><p>Pre-allocated version of <code>steady_state_analysis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/analyses.jl#L271-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.eigenvalue_analysis" href="#GXBeam.eigenvalue_analysis"><code>GXBeam.eigenvalue_analysis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigenvalue_analysis(assembly; kwargs...)</code></pre><p>Compute the eigenvalues and eigenvectors of the system of nonlinear beams contained in <code>assembly</code>.  Return the modified system, eigenvalues, eigenvectors, and a convergence flag indicating whether the corresponding steady-state analysis converged.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}()</code>:      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and values of type      <a href="#GXBeam.PrescribedConditions"><code>PrescribedConditions</code></a> which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.</li><li><code>distributed_loads = Dict{Int,DistributedLoads{Float64}}()</code>: A dictionary      with keys corresponding to the elements to which distributed loads are      applied and values of type <a href="#GXBeam.DistributedLoads"><code>DistributedLoads</code></a> which describe      the distributed loads on those elements.  If time varying, this input may      be provided as a function of time.</li><li><code>point_masses = Dict{Int,PointMass{Float64}}()</code>: A dictionary with keys       corresponding to the beam elements to which point masses are attached and values       of type <a href="#GXBeam.PointMass"><code>PointMass</code></a> which contain the properties of the attached       point masses.  If time varying, this input may be provided as a function of time.</li><li><code>gravity = [0,0,0]</code>: Gravity vector.  If time varying, this input may be provided as a       function of time.            </li><li><code>linear = false</code>: Set to <code>true</code> for a linear analysis</li><li><code>linearization_state</code>: Linearization state variables.  Defaults to zeros.</li><li><code>update_linearization_state</code>: Flag indicating whether to update the linearization state   variables for a linear analysis with the current state variables.</li><li><code>method = :newton</code>: Method (as defined in NLsolve) to solve nonlinear system of equations</li><li><code>linesearch = LineSearches.LineSearches.BackTracking(maxstep=1e6)</code>: Line search used to solve nonlinear system of equations</li><li><code>ftol = 1e-9</code>: tolerance for solving nonlinear system of equations</li><li><code>iterations = 1000</code>: maximum iterations for solving the nonlinear system of equations</li><li><code>reset_state = true</code>: Flag indicating whether the state variables should be  reset prior to performing the steady-state analysis.  This keyword argument  is only valid for the pre-allocated version of this function.</li><li><code>find_steady_state = reset_state &amp;&amp; !linear</code>: Flag indicating whether the  steady state solution should be found prior to performing the eigenvalue analysis.</li><li><code>origin = zeros(3)</code>: Global frame origin.  If time varying, this vector may be provided as a function of time.</li><li><code>linear_velocity = zeros(3)</code>: Global frame linear velocity vector.  If time varying, this vector may be provided as a function of time.</li><li><code>angular_velocity = zeros(3)</code>: Global frame angular velocity vector.  If time varying, this vector may be provided as a function of time.</li><li><code>linear_acceleration = zeros(3)</code>: Global frame linear acceleration vector. If time  varying, this vector may be provided as a function of time.</li><li><code>angular_acceleration = zeros(3)</code>: Global frame angular acceleration vector. If time  varying, this vector may be provided as a function of time.</li><li><code>tvec</code>: Time vector. May be used in conjunction with time varying  prescribed conditions, distributed loads, and global motion to gradually  increase displacements/loads during the steady-state analysis.</li><li><code>nev = 6</code>: Number of eigenvalues to compute</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/analyses.jl#L378-L431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.eigenvalue_analysis!" href="#GXBeam.eigenvalue_analysis!"><code>GXBeam.eigenvalue_analysis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigenvalue_analysis!(system, assembly; kwargs...)</code></pre><p>Pre-allocated version of <code>eigenvalue_analysis</code>.  Uses the state variables stored in <code>system</code> as an initial guess for iterating to find the steady state solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/analyses.jl#L484-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_condition_analysis" href="#GXBeam.initial_condition_analysis"><code>GXBeam.initial_condition_analysis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_condition_analysis(assembly, t0; kwargs...)</code></pre><p>Perform an analysis to obtain a consistent set of initial conditions.  Return the final system with the new initial conditions.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>prescribed_conditions: A dictionary with keys corresponding to the points at      which prescribed conditions are applied and values of type      [</code>PrescribedConditions`](@ref) which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.</li><li><code>distributed_loads: A dictionary with keys corresponding to the elements to      which distributed loads are applied and values of type      [</code>DistributedLoads`](@ref) which describe the distributed loads at those      points.  If time varying, this input may be provided as a function of      time.</li><li><code>point_masses = Dict{Int,PointMass{Float64}}()</code>: A dictionary with keys       corresponding to the beam elements to which point masses are attached and values       of type <a href="#GXBeam.PointMass"><code>PointMass</code></a> which contain the properties of the attached       point masses.  If time varying, this input may be provided as a function of time.</li><li><code>gravity = [0,0,0]</code>: Gravity vector.  If time varying, this input may be provided as a       function of time.</li><li><code>linear = false</code>: Set to <code>true</code> for a linear analysis</li><li><code>linearization_state</code>: Linearization state variables.  Defaults to zeros.</li><li><code>method = :newton</code>: Method (as defined in NLsolve) to solve nonlinear system of equations</li><li><code>linesearch = LineSearches.LineSearches.BackTracking(maxstep=1e6)</code>: Line search used to solve nonlinear system of equations</li><li><code>ftol = 1e-9</code>: tolerance for solving nonlinear system of equations</li><li><code>iterations = 1000</code>: maximum iterations for solving the nonlinear system of equations</li><li><code>reset_state = true</code>: Flag indicating whether the state variables should be  reset prior to performing the analysis.  This keyword argument is only valid  for the pre-allocated version of this function.</li><li><code>origin = zeros(3)</code>: Global frame origin.  If time varying, this vector may be provided as a function of time.</li><li><code>linear_velocity = zeros(3)</code>: Global frame linear velocity vector.  If time varying, this vector may be provided as a function of time.</li><li><code>angular_velocity = zeros(3)</code>: Global frame angular velocity vector.  If time varying, this vector may be provided as a function of time.</li><li><code>linear_acceleration = zeros(3)</code>: Global frame linear acceleration vector. If time  varying, this vector may be provided as a function of time.</li><li><code>angular_acceleration = zeros(3)</code>: Global frame angular acceleration vector. If time  varying, this vector may be provided as a function of time.</li><li><code>u0=fill(zeros(3), length(assembly.elements))</code>: Initial displacment of each beam element,</li><li><code>theta0=fill(zeros(3), length(assembly.elements))</code>: Initial angular displacement of each beam element,</li><li><code>udot0=fill(zeros(3), length(assembly.elements))</code>: Initial time derivative with respect to <code>u</code></li><li><code>thetadot0=fill(zeros(3), length(assembly.elements))</code>: Initial time derivative with respect to <code>theta</code></li><li><code>save=1:length(tvec)</code>: Steps at which to save the time history</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/analyses.jl#L612-L659">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_condition_analysis!" href="#GXBeam.initial_condition_analysis!"><code>GXBeam.initial_condition_analysis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_condition_analysis!(system, assembly, t0; kwargs...)</code></pre><p>Pre-allocated version of <code>initial_condition_analysis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/analyses.jl#L712-L716">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.time_domain_analysis" href="#GXBeam.time_domain_analysis"><code>GXBeam.time_domain_analysis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">time_domain_analysis(assembly, tvec; kwargs...)</code></pre><p>Perform a time-domain analysis for the system of nonlinear beams contained in <code>assembly</code> using the time vector <code>tvec</code>.  Return the final system, a post-processed solution history, and a convergence flag indicating whether the iterations converged for each time step.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>prescribed_conditions: A dictionary with keys corresponding to the points at      which prescribed conditions are applied and values of type      [</code>PrescribedConditions`](@ref) which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.</li><li><code>distributed_loads: A dictionary with keys corresponding to the elements to      which distributed loads are applied and values of type      [</code>DistributedLoads`](@ref) which describe the distributed loads at those      points.  If time varying, this input may be provided as a function of      time.</li><li><code>point_masses = Dict{Int,PointMass{Float64}}()</code>: A dictionary with keys       corresponding to the beam elements to which point masses are attached and values       of type <a href="#GXBeam.PointMass"><code>PointMass</code></a> which contain the properties of the attached       point masses.  If time varying, this input may be provided as a function of time.</li><li><code>gravity = [0,0,0]</code>: Gravity vector.  If time varying, this input may be provided as a       function of time.</li><li><code>linear = false</code>: Set to <code>true</code> for a linear analysis</li><li><code>linearization_state</code>: Linearization state variables.  Defaults to zeros.</li><li><code>update_linearization_state</code>: Flag indicating whether to update the linearization state   variables for a linear analysis with the current state variables.</li><li><code>method = :newton</code>: Method (as defined in NLsolve) to solve nonlinear system of equations</li><li><code>linesearch = LineSearches.LineSearches.BackTracking(maxstep=1e6)</code>: Line search used to solve nonlinear system of equations</li><li><code>ftol = 1e-9</code>: tolerance for solving nonlinear system of equations</li><li><code>iterations = 1000</code>: maximum iterations for solving the nonlinear system of equations</li><li><code>reset_state = true</code>: Flag indicating whether the state variables should be  reset prior to performing the analysis.  This keyword argument is only valid  for the pre-allocated version of this function.</li><li><code>initialize = true</code>: Flag indicating whether a consistent set of initial  conditions should be found using <a href="#GXBeam.initial_condition_analysis"><code>initial_condition_analysis</code></a>. If  <code>false</code>, the keyword arguments <code>u0</code>, <code>theta0</code>, <code>udot0</code> and <code>thetadot0</code> will  be ignored and the system state vector will be used as the initial state  variables.</li><li><code>origin</code>: Global frame origin vector. If time varying, this input  may be provided as a function of time.</li><li><code>linear_velocity</code>: Global frame linear velocity vector. If time  varying, this vector may be provided as a function of time.</li><li><code>angular_velocity</code>: Global frame angular velocity vector. If time  varying, this vector may be provided as a function of time.</li><li><code>linear_acceleration = zeros(3)</code>: Global frame linear acceleration vector. If time  varying, this vector may be provided as a function of time.</li><li><code>angular_acceleration = zeros(3)</code>: Global frame angular acceleration vector. If time  varying, this vector may be provided as a function of time.</li><li><code>u0=fill(zeros(3), length(assembly.elements))</code>: Initial displacment of each beam element,</li><li><code>theta0=fill(zeros(3), length(assembly.elements))</code>: Initial angular displacement of each beam element,</li><li><code>udot0=fill(zeros(3), length(assembly.elements))</code>: Initial time derivative with respect to <code>u</code></li><li><code>thetadot0=fill(zeros(3), length(assembly.elements))</code>: Initial time derivative with respect to <code>theta</code></li><li><code>save=1:length(tvec)</code>: Steps at which to save the time history</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/analyses.jl#L833-L889">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.time_domain_analysis!" href="#GXBeam.time_domain_analysis!"><code>GXBeam.time_domain_analysis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">time_domain_analysis!(system, assembly, tvec; kwargs...)</code></pre><p>Pre-allocated version of <code>time_domain_analysis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/analyses.jl#L948-L952">source</a></section></article><h3 id="Post-Processing"><a class="docs-heading-anchor" href="#Post-Processing">Post-Processing</a><a id="Post-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#Post-Processing" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.AssemblyState" href="#GXBeam.AssemblyState"><code>GXBeam.AssemblyState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AssemblyState{TF, TP&lt;:AbstractVector{PointState{TF}},
    TE&lt;:AbstractVector{ElementState{TF}}}</code></pre><p>Struct for storing state variables for the points and elements in an assembly.</p><p><strong>Fields:</strong></p><ul><li><code>points::TP</code>: Array of <code>PointState</code>s for each point in the assembly</li><li><code>elements::TE</code>: Array of <code>ElementState</code>s for each element in the assembly</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L42-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.PointState" href="#GXBeam.PointState"><code>GXBeam.PointState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PointState</code></pre><p>Holds the state variables for a point</p><p><strong>Fields:</strong></p><ul><li><code>u</code>: Displacement variables for the point (in the global coordinate frame)</li><li><code>theta</code>: Wiener-Milenkovic rotational displacement variables for the point</li><li><code>F</code>: Externally applied forces on the point (in the global coordinate frame)</li><li><code>M</code>: Externally applied moments on the point (in the global coordinate frame)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.ElementState" href="#GXBeam.ElementState"><code>GXBeam.ElementState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ElementState</code></pre><p>Holds the state variables for an element</p><p><strong>Fields:</strong></p><ul><li><code>u</code>: Displacement variables for the element (in the global coordinate frame)</li><li>theta: Wiener-Milenkovic rotational displacement variables for the element     (in the global coordinate frame)</li><li><code>F</code>: Resultant forces for the element (in the deformed local coordinate frame)</li><li><code>M</code>: Resultant moments for the element (in the deformed local coordinate frame)</li><li><code>V</code>: Linear velocity of the element (in the deformed local coordinate frame)</li><li><code>Omega</code>: Angular velocity of the element (in the deformed local coordinate frame)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L19-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.AssemblyState-Tuple{Any, Any}" href="#GXBeam.AssemblyState-Tuple{Any, Any}"><code>GXBeam.AssemblyState</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AssemblyState(system, assembly, x = system.x;
    prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())</code></pre><p>Post-process the system state given the solution vector <code>x</code>.  Return an object of type <code>AssemblyState</code> that defines the state of the assembly for the time step.</p><p>If <code>prescribed_conditions</code> is not provided, all point state variables are assumed to be displacements/rotations, rather than their actual identities as used in the analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L58-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.extract_element_state" href="#GXBeam.extract_element_state"><code>GXBeam.extract_element_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_element_state(system, ielem, x = system.x)</code></pre><p>Return the state variables corresponding to element <code>ielem</code> (see <a href="#GXBeam.ElementState"><code>ElementState</code></a>) given the solution vector <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L186-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.extract_element_states" href="#GXBeam.extract_element_states"><code>GXBeam.extract_element_states</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_element_states(system, x = system.x)</code></pre><p>Return the state variables corresponding to each element (see <a href="#GXBeam.ElementState"><code>ElementState</code></a>) given the solution vector <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L215-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.extract_element_states!" href="#GXBeam.extract_element_states!"><code>GXBeam.extract_element_states!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_element_states!(elements, system, x = system.x)</code></pre><p>Pre-allocated version of <a href="#GXBeam.extract_element_states"><code>extract_element_states</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L227-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.extract_point_state" href="#GXBeam.extract_point_state"><code>GXBeam.extract_point_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_point_state(system, assembly, ipoint, x = system.x;
    prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())</code></pre><p>Return the state variables corresponding to point <code>ipoint</code> (see <a href="#GXBeam.PointState"><code>PointState</code></a>) given the solution vector <code>x</code>.</p><p>If <code>prescribed_conditions</code> is not provided, all point state variables are assumed to be displacements/rotations, rather than their actual identities as used in the analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L79-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.extract_point_states" href="#GXBeam.extract_point_states"><code>GXBeam.extract_point_states</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_point_states(system, assembly, x = system.x;
    prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())</code></pre><p>Return the state variables corresponding to each point (see <a href="#GXBeam.PointState"><code>PointState</code></a>) given the solution vector <code>x</code>.</p><p>If <code>prescribed_conditions</code> is not provided, all point state variables are assumed to be displacements/rotations, rather than their actual identities as used in the analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L153-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.extract_point_states!" href="#GXBeam.extract_point_states!"><code>GXBeam.extract_point_states!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_point_states!(points, system, assembly, x = system.x;
    prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())</code></pre><p>Pre-allocated version of <a href="#GXBeam.extract_point_states"><code>extract_point_states</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L170-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.left_eigenvectors" href="#GXBeam.left_eigenvectors"><code>GXBeam.left_eigenvectors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">left_eigenvectors(system, λ, V)
left_eigenvectors(K, M, λ, V)</code></pre><p>Compute the left eigenvector matrix <code>U</code> for the <code>system</code> using inverse power iteration given the eigenvalues <code>λ</code> and the corresponding right eigenvector matrix <code>V</code>.</p><p>The complex conjugate of each left eigenvector is stored in each row of the matrix <code>U</code></p><p>Left and right eigenvectors satisfy the following M-orthogonality condition:</p><ul><li>u&#39;<em>M</em>v = 1 if u and v correspond to the same eigenvalue</li><li>u&#39;<em>M</em>v = 0 if u and v correspond to different eigenvalues</li></ul><p>This means that U<em>M</em>V = I</p><p>This function assumes that <code>system</code> has not been modified since the eigenvalues and right eigenvectors were computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L819-L837">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.correlate_eigenmodes" href="#GXBeam.correlate_eigenmodes"><code>GXBeam.correlate_eigenmodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">correlate_eigenmodes(C)</code></pre><p>Return the permutation and the associated corruption index vector which associates eigenmodes from the current iteration with those of the previous iteration given the correlation matrix <code>C</code>.</p><p>The correlation matrix can take one of the following forms (in order of preference):</p><ul><li><code>C = U_p*M*V</code></li><li><code>C = U*M_p*V_p</code></li><li><code>C = V_p&#39;*V</code></li><li><code>C = V&#39;*V_p</code></li></ul><p>where <code>U</code> is a matrix of conjugated left eigenvectors, <code>M</code> is the system mass matrix, <code>V</code> is a matrix of right eigenvectors, and <code>()_p</code> indicates a variable from the previous iteration.</p><p>Note that the following two forms of the correlation matrix seem to be significantly inferior to their counterparts listed above: <code>C = U*M*V_p</code> and <code>C = U_p*M_p*V</code>. This is likely due to the way in which the left eigenvector matrix is calculated.</p><p>The corruption index is the largest magnitude in a given row of <code>C</code> that was not chosen divided by the magnitude of the chosen eigenmode.  It is most meaningful when using one of the forms of the correlation matrix that uses left eigenvectors since correct eigenmodes will have magnitudes close to 1 and incorrect eigenmodes will have magnitudes close to 0.</p><p>If the new mode number is already assigned, the next highest unassigned mode number is used.  In this case a corruption index higher than 1 will be returned, otherwise the values of the corruption index will always be bounded by 0 and 1.</p><p>See &quot;New Mode Tracking Methods in Aeroelastic Analysis&quot; by Eldred, Vankayya, and Anderson.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L937-L969">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.wiener_milenkovic" href="#GXBeam.wiener_milenkovic"><code>GXBeam.wiener_milenkovic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wiener_milenkovic(c)</code></pre><p>Construct a Wiener-Milenkovic transformation matrix, given the three Wiener-Milenkovic parameters in <code>c</code>.</p><p>Note that the corresponding rotation matrix is the transpose of this transformation matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/math.jl#L15-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.rotate" href="#GXBeam.rotate"><code>GXBeam.rotate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotate(xyz, r, theta)</code></pre><p>Rotate the vectors in <code>xyz</code> about point <code>r</code> using the Wiener-Milenkovic parameters in <code>theta</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L239-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.rotate!" href="#GXBeam.rotate!"><code>GXBeam.rotate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotate!(xyz, r, theta)</code></pre><p>Pre-allocated version of <a href="#GXBeam.rotate"><code>rotate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L247-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.translate" href="#GXBeam.translate"><code>GXBeam.translate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">translate(xyz, u)</code></pre><p>Translate the points in <code>xyz</code> by the displacements in <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L269-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.translate!" href="#GXBeam.translate!"><code>GXBeam.translate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">translate!(xyz, u)</code></pre><p>Pre-allocated version of <a href="#GXBeam.translate"><code>translate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L276-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.deform_cross_section" href="#GXBeam.deform_cross_section"><code>GXBeam.deform_cross_section</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deform_cross_section(xyz, r, u, theta)</code></pre><p>Rotate the points in <code>xyz</code> (of shape (3, :)) about point <code>r</code> using the Wiener-Milenkovic parameters in <code>theta</code>, then translate the points by the displacements in <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L295-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.deform_cross_section!" href="#GXBeam.deform_cross_section!"><code>GXBeam.deform_cross_section!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deform_cross_section!(xyz, r, u, theta)</code></pre><p>Pre-allocated version of <a href="#GXBeam.deform_cross_section"><code>deform_cross_section</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L304-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.cross_section_velocities" href="#GXBeam.cross_section_velocities"><code>GXBeam.cross_section_velocities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cross_section_velocities(xyz, r, v, ω)</code></pre><p>Calculate the velocities of the points in <code>xyz</code> given the linear velocity <code>v</code>, and the angular velocity <code>ω</code> about point <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L311-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.cross_section_velocities!" href="#GXBeam.cross_section_velocities!"><code>GXBeam.cross_section_velocities!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cross_section_velocities!(vxyz, xyz, r, v, ω)</code></pre><p>Pre-allocated version of <a href="#GXBeam.cross_section_velocities"><code>cross_section_velocities</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L323-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.write_vtk" href="#GXBeam.write_vtk"><code>GXBeam.write_vtk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write_vtk(name, assembly::Assembly; kwargs...)
write_vtk(name, assembly::Assembly, state::AssemblyState; kwargs...)
write_vtk(name, assembly::Assembly, history::Vector{&lt;:AssemblyState}], dt;
    kwargs...)</code></pre><p>Write the deformed geometry (and associated data) to a VTK file for visualization using ParaView.</p><p>The <code>state</code> argument may be omitted to write the original geometry to a VTK file without any associated data.</p><p>If the solution time <code>history</code> is provided, the time step must also be provided</p><p><strong>Keyword Arguments</strong></p><ul><li><code>sections = nothing</code>: Cross section geometry corresponding to each point,  defined in a frame aligned with the global frame but centered around the  corresponding point. Defined as an array with shape <code>(3, ncross, np)</code> where <code>ncross</code>  is the number of points in each cross section and <code>np</code> is the number of points.</li><li><code>scaling=1.0</code>: Parameter to scale the deflections (only valid if state is provided)</li><li><code>metadata=Dict()</code>: Dictionary of metadata for the file(s)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L345-L366">source</a></section><section><div><pre><code class="nohighlight hljs">write_vtk(name, assembly::Assembly, [state::AssemblyState, ]λ::Number,
    eigenstate::AssemblyState; scaling=1.0, mode_scaling=1.0, cycles=1,
    steps=100)</code></pre><p>Write a series of files corresponding to the elastic motion of the <code>assembly</code> about the deformed state encoded in <code>state</code> defined by the eigenvalue <code>λ</code> and the eigenvector encoded in <code>eigenstate</code> over the time period specified by <code>time</code>.</p><p>The steady-state deflections can be scaled with <code>scaling</code> and the eigenmode deflections can be scaled using <code>mode_scaling</code>.</p><p>The current time is encoded in the metadata tag &quot;time&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/postprocess.jl#L668-L681">source</a></section></article><h2 id="Private-API"><a class="docs-heading-anchor" href="#Private-API">Private API</a><a id="Private-API-1"></a><a class="docs-heading-anchor-permalink" href="#Private-API" title="Permalink"></a></h2><h3 id="Math"><a class="docs-heading-anchor" href="#Math">Math</a><a id="Math-1"></a><a class="docs-heading-anchor-permalink" href="#Math" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.tilde" href="#GXBeam.tilde"><code>GXBeam.tilde</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tilde(x)</code></pre><p>Construct the cross product operator matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/math.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.transform_properties" href="#GXBeam.transform_properties"><code>GXBeam.transform_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_properties(K, T)</code></pre><p>Applies the transformation <code>T</code> to the stiffness or mass matrix <code>K</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/math.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.rotation_parameter_scaling" href="#GXBeam.rotation_parameter_scaling"><code>GXBeam.rotation_parameter_scaling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation_parameter_scaling(θ)</code></pre><p>Extract a scaling parameter which may be multiplied by the angular parameters to yield the Wiener-Milenkovic rotation parameters.  Use of this scaling parameter allows deflections greater than 360 degrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/math.jl#L45-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_C" href="#GXBeam.get_C"><code>GXBeam.get_C</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_C(θ)</code></pre><p>Returns the transformation matrix <code>C</code> given the three angular parameters in <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/math.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_C_t" href="#GXBeam.get_C_t"><code>GXBeam.get_C_t</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_C_t([C, ] θ, θ_t)</code></pre><p>Calculate the derivative of the Wiener-Milenkovic transformation matrix <code>C</code> with respect to the scalar parameter <code>t</code>. <code>θ_t</code> is the derivative of the angular parameter <code>θ</code> with respect to <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/math.jl#L87-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_C_θ" href="#GXBeam.get_C_θ"><code>GXBeam.get_C_θ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_C_θ([C, ] θ)</code></pre><p>Calculate the derivative of the Wiener-Milenkovic transformation matrix <code>C</code> with respect to each of the rotation parameters in <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/math.jl#L123-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_C_t_θ" href="#GXBeam.get_C_t_θ"><code>GXBeam.get_C_t_θ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_C_t_θ(θ, θ_t)</code></pre><p>Calculate the derivative of the time derivative of the Wiener-Milenkovic transformation matrix <code>C</code> with respect to <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/math.jl#L167-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_C_t_θdot" href="#GXBeam.get_C_t_θdot"><code>GXBeam.get_C_t_θdot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_C_t_θdot([C, ] θ)</code></pre><p>Calculate the derivative of the time derivative of the Wiener-Milenkovic transformation matrix <code>C</code> with respect to each of the time derivatives of <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/math.jl#L183-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_Q" href="#GXBeam.get_Q"><code>GXBeam.get_Q</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_Q(θ)</code></pre><p>Calculate the matrix Q as defined in the paper &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu given the rotational parameters in <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/math.jl#L225-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_Q_θ" href="#GXBeam.get_Q_θ"><code>GXBeam.get_Q_θ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_Q_θ(θ)
get_Q_θ(Q, θ)</code></pre><p>Calculate the derivative of the matrix <code>Q</code> with respect to each of the rotation parameters in <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/math.jl#L243-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_Qinv" href="#GXBeam.get_Qinv"><code>GXBeam.get_Qinv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_Qinv(θ)</code></pre><p>Calculate the matrix inverse <code>Qinv</code> as defined in the paper &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu given the rotational parameters in <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/math.jl#L273-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_Qinv_θ" href="#GXBeam.get_Qinv_θ"><code>GXBeam.get_Qinv_θ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_Qinv_θ(θ)</code></pre><p>Calculate the derivative of the matrix inverse <code>Qinv</code> with respect to each of the rotation parameters in <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/math.jl#L291-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.mul3" href="#GXBeam.mul3"><code>GXBeam.mul3</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mul3(A_1, A_2, A_3, b)</code></pre><p>Return the product of a 3x3x3 tensor represented by <code>A_1</code>, <code>A_2</code>, and <code>A_3</code> with the vector <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/math.jl#L310-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.gauss_quadrature" href="#GXBeam.gauss_quadrature"><code>GXBeam.gauss_quadrature</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gauss_quadrature(f, a, b)</code></pre><p>Default gauss-quadrature function used for integrating distributed loads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/math.jl#L318-L322">source</a></section></article><h3 id="Points"><a class="docs-heading-anchor" href="#Points">Points</a><a id="Points-1"></a><a class="docs-heading-anchor-permalink" href="#Points" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.point_variables" href="#GXBeam.point_variables"><code>GXBeam.point_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_variables(x, icol)
point_variables(x, icol, prescribed_conditions)</code></pre><p>Extract u, θ, F, M for the point described by the point state variables at <code>icol</code> in x after incorporating the prescribed conditions in <code>prescribed_conditions</code></p><p>Note that the degrees of freedom that are not specified in <code>prescribed_conditions</code> are used as state variables (e.g. prescribing F[2] would mean u[2] = x[icol+1])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/point.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.insert_point_residual!" href="#GXBeam.insert_point_residual!"><code>GXBeam.insert_point_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_point_residual!(resid, irow_elem, irow_point, u, θ, F, M, side)</code></pre><p>Modify the equilibrium and constitutive equations to account for the point variables given by u, θ, F, M</p><p>If <code>irow_elem != irow_point</code>, assume that the equilibrium equations have already been modified</p><p><strong>Arguments</strong></p><ul><li>resid: Residual vector</li><li>irow_elem: Row index of the first equilibrium/compatability equation for one     side of the beam element</li><li>irow_point: Row index of the first equilibrium equation for the point</li><li>u: Displacement of the point</li><li>θ: Rotation of the point</li><li>F: External forces imposed on the point</li><li>M: External moments imposed on the point</li><li>side: Side of beam element (-1 (left) or 1 (right))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/point.jl#L72-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.point_residual!" href="#GXBeam.point_residual!"><code>GXBeam.point_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_residual!(resid, x, ipoint, assembly, prescribed_conditions,
    force_scaling, icol, irow_point, irow_elem1, irow_elem2)</code></pre><p>Adds a points contributions to the residual vector</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: residual vector</li><li><code>x</code>: current state vector</li><li><code>ipoint</code>: index of point</li><li><code>assembly</code>: assembly of interconnected beam elements</li><li><code>prescribed_conditions</code>: dictionary of prescribed conditions</li><li><code>force_scaling</code>: scaling parameter for forces</li><li><code>icol</code>: starting index for the point&#39;s state variables</li><li><code>irow_point</code>: Row index of the first equilibrium equation for the point</li><li><code>irow_elem1</code>: Row index of first equation for the left side of each beam element</li><li><code>irow_elem2</code>: Row index of first equation for the right side of each beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/point.jl#L113-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.point_follower_jacobians" href="#GXBeam.point_follower_jacobians"><code>GXBeam.point_follower_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_follower_jacobians(x, icol, prescribed_conditions)</code></pre><p>Calculate the jacobians of the follower forces/moments with respect to θ</p><p><strong>Arguments</strong></p><ul><li>x: Current state variable vector</li><li>icol: Row/Column index of the first state variable for the point</li><li>prescribed_conditions: Prescribed conditions for the point</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/point.jl#L165-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.insert_point_jacobian!" href="#GXBeam.insert_point_jacobian!"><code>GXBeam.insert_point_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_point_jacobian!(jacob, irow_elem, irow_point, icol,
    prescribed_conditions, side, F_θ, M_θ)</code></pre><p>Modify the jacobian entries for the equilibrium and constitutive equations to account for the point variables at icol</p><p>If irow<em>elem != irow</em>point, assume that the equilibrium equations have already been modified</p><p><strong>Arguments</strong></p><ul><li>jacob: Jacobian of residual vector with respect to state vectors</li><li>irow_elem: Row index of the first equilibrium/compatability equation for one side of the beam element</li><li>irow_point: Row index of the first equilibrium equation for the point</li><li>icol: Row/Column index of the first state variable for the point</li><li>prescribed_conditions: Prescribed force/displacement and moment/rotation on point</li><li>side: Side of beam element (-1 (left) or 1 (right))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/point.jl#L232-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.point_jacobian!" href="#GXBeam.point_jacobian!"><code>GXBeam.point_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_jacobian!(jacob, x, ipoint, assembly, prescribed_conditions, icol,
    irow_point, irow_elem1, irow_elem2)</code></pre><p>Adds a points contributions to the residual vector</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: residual vector</li><li><code>x</code>: current state vector</li><li><code>ipoint</code>: index of point</li><li><code>assembly</code>: assembly of interconnected beam elements</li><li><code>prescribed_conditions</code>: dictionary of prescribed conditions</li><li><code>force_scaling</code>: scaling parameter for forces</li><li><code>icol</code>: starting index for the point&#39;s state variables</li><li><code>irow_point</code>: Row index of the first equilibrium equation for the point</li><li><code>irow_elem1</code>: Row index of first equation for the left side of each beam element</li><li><code>irow_elem2</code>: Row index of first equation for the right side of each beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/point.jl#L311-L328">source</a></section></article><h3 id="Elements"><a class="docs-heading-anchor" href="#Elements">Elements</a><a id="Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Elements" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_strain" href="#GXBeam.element_strain"><code>GXBeam.element_strain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">element_strain(element, F, M)</code></pre><p>Calculate the strain of a beam element given the resultant forces and moments applied on the element expressed in the deformed beam element frame</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_curvature" href="#GXBeam.element_curvature"><code>GXBeam.element_curvature</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">element_curvature(element, F, M)</code></pre><p>Calculate the curvature of a beam element given the resultant force and moments applied on the element expressed in the deformed beam element frame</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_linear_momentum" href="#GXBeam.element_linear_momentum"><code>GXBeam.element_linear_momentum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">element_linear_momentum(element, V, Ω)</code></pre><p>Calculate the linear momentum of a beam element given the linear and angular velocity of the element expressed in the deformed beam element frame</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_angular_momentum" href="#GXBeam.element_angular_momentum"><code>GXBeam.element_angular_momentum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">element_angular_momentum(element, V, Ω)</code></pre><p>Calculate the angular momentum of a beam element given the linear and angular velocity of the element expressed in the deformed beam element frame</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L77-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_element_state_variables" href="#GXBeam.static_element_state_variables"><code>GXBeam.static_element_state_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_element_state_variables(x, icol, force_scaling)</code></pre><p>Return element state variables for a static analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_element_state_variables" href="#GXBeam.dynamic_element_state_variables"><code>GXBeam.dynamic_element_state_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_element_state_variables(x, icol, force_scaling)</code></pre><p>Return element state variables for a dynamic analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_element_equations" href="#GXBeam.static_element_equations"><code>GXBeam.static_element_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_element_equations(ΔL, Cab, CtCab, u, θ, F, M, γ, κ, f1, f2, m1, m2)</code></pre><p>Calculate the element resultants for a static analysis.</p><p><strong>Arguments:</strong></p><ul><li><code>ΔL</code>: length</li><li><code>Cab</code>: transformation matrix from the undeformed beam element frame to the body frame</li><li><code>CtCab</code>: transformation matrix from the deformed beam element frame to the body frame</li><li><code>u</code>: linear displacement</li><li><code>θ</code>: angular displacement</li><li><code>F</code>: internal force</li><li><code>M</code>: internal moment</li><li><code>γ</code>: engineering strain</li><li><code>κ</code>: curvature</li><li><code>f1</code>: integrated force applied to the start of the beam element</li><li><code>f2</code>: integrated force applied to the end of the beam element</li><li><code>m1</code>: integrated moment applied to the start of the beam element</li><li><code>m2</code>: integrated moment applied to the end of the beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L118-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_state_element_equations" href="#GXBeam.steady_state_element_equations"><code>GXBeam.steady_state_element_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_state_element_equations(ΔL, Cab, CtCab, u, θ, F, M, γ, κ, V, Ω, P, H, v, ω, 
    f1, f2, m1, m2)</code></pre><p>Calculate the element resultants for a steady state analysis.</p><p><strong>Arguments:</strong></p><ul><li><code>ΔL</code>: length</li><li><code>Cab</code>: transformation matrix from the undeformed beam element frame to the body frame</li><li><code>CtCab</code>: transformation matrix from the deformed beam element frame to the body frame</li><li><code>u</code>: linear displacement</li><li><code>θ</code>: angular displacement</li><li><code>F</code>: internal force</li><li><code>M</code>: internal moment</li><li><code>γ</code>: engineering strain</li><li><code>κ</code>: curvature</li><li><code>V</code>: linear velocity</li><li><code>Ω</code>: angular velocity</li><li><code>P</code>: linear momentum</li><li><code>H</code>: angular momentum</li><li><code>v</code>: linear velocity caused by body frame velocity</li><li><code>ω</code>: angular velocity caused by body frame velocity</li><li><code>f1</code>: integrated force applied to the start of the beam element</li><li><code>f2</code>: integrated force applied to the end of the beam element</li><li><code>m1</code>: integrated moment applied to the start of the beam element</li><li><code>m2</code>: integrated moment applied to the end of the beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L161-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_element_equations" href="#GXBeam.dynamic_element_equations"><code>GXBeam.dynamic_element_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_element_equations(ΔL, Cab, CtCab, u, θ, F, M, γ, κ, V, Ω, P, H, v, ω, 
    f1, f2, m1, m2, udot, θdot, CtCabPdot, CtCabHdot)</code></pre><p>Calculate the element resultants for a dynamic analysis.</p><p><strong>Arguments:</strong></p><ul><li><code>ΔL</code>: length</li><li><code>Cab</code>: transformation matrix from the undeformed beam element frame to the body frame</li><li><code>CtCab</code>: transformation matrix from the deformed beam element frame to the body frame</li><li><code>u</code>: linear displacement</li><li><code>θ</code>: angular displacement</li><li><code>F</code>: internal force</li><li><code>M</code>: internal moment</li><li><code>γ</code>: engineering strain</li><li><code>κ</code>: curvature</li><li><code>V</code>: linear velocity</li><li><code>Ω</code>: angular velocity</li><li><code>P</code>: linear momentum</li><li><code>H</code>: angular momentum</li><li><code>v</code>: linear velocity from body frame velocity</li><li><code>ω</code>: angular velocity from body frame velocity</li><li><code>f1</code>: integrated force applied to the start of the beam element</li><li><code>f2</code>: integrated force applied to the end of the beam element</li><li><code>m1</code>: integrated moment applied to the start of the beam element</li><li><code>m2</code>: integrated moment applied to the end of the beam element</li><li><code>udot</code>: linear displacement rate, expressed in the body frame</li><li><code>θdot</code>: angular displacement rate, expressed in the body frame</li><li><code>CtCabPdot</code>: linear momentum rate, expressed in the body frame</li><li><code>CtCabHdot</code>: angular momentum rate, expressed in the body frame</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L208-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_insert_element_residual!" href="#GXBeam.static_insert_element_residual!"><code>GXBeam.static_insert_element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_insert_element_residual!(resid, force_scaling, irow_e1, 
    irow_p1, irow_e2, irow_p2, f_u1, f_u2, f_ψ1, f_ψ2, f_F1, f_F2, f_M1, f_M2)</code></pre><p>Add beam element resultants to the residuals for a static analysis.  Initialize  equilibrium and constitutive equation residuals if they are not yet initialized.</p><p>If <code>irow_e1 != irow_p1</code> and/or <code>irow_e2 != irow_p2</code>, assume the equilibrium equation  residuals for the start and/or end of the beam element are already initialized</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: system residual vector</li><li><code>force_scaling</code>: scaling parameter for forces</li><li><code>irow_e1</code>: row index of the first residual equation for the start of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: row index of the first residual equation for the point at the start of the   beam element</li><li><code>irow_e2</code>: row index of the first residual equation for the end of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: row index of the first residual equation for the point at the end of the   beam element</li><li><code>f_u1</code>, <code>f_u2</code>: beam element resultant forces</li><li><code>f_ψ1</code>, <code>f_ψ2</code>: beam element resultant moments</li><li><code>f_F1</code>, <code>f_F2</code>: beam element resultant linear displacements</li><li><code>f_M1</code>, <code>f_M2</code>: beam element resultant angular displacements</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L264-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_insert_element_residual!" href="#GXBeam.dynamic_insert_element_residual!"><code>GXBeam.dynamic_insert_element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_insert_element_residual!(resid, force_scaling, irow_e, irow_e1, irow_p1, 
    irow_e2, irow_p2, f_u1, f_u2, f_ψ1, f_ψ2, f_F1, f_F2, f_M1, f_M2, f_V, f_Ω)</code></pre><p>Add beam element resultants into the residuals for a general dynamic analysis.  Initialize  equilibrium and constitutive equation residuals if they are not yet initialized.</p><p>If <code>irow_e1 != irow_p1</code> and/or <code>irow_e2 != irow_p2</code>, assume the equilibrium equation  residuals for the start and/or end of the beam element are already initialized</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: system residual vector</li><li><code>force_scaling</code>: scaling parameter for forces</li><li><code>irow_e</code>: row index of the first linear/angular velocity residual for this element</li><li><code>irow_e1</code>: row index of the first residual equation for the start of the beam element (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: row index of the first residual equation for the point at the start of the  beam element</li><li><code>irow_e2</code>: row index of the first residual equation for the end of the beam element (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: row index of the first residual equation for the point at the end of the  beam element</li><li><code>f_u1</code>, <code>f_u2</code>: beam element resultant forces</li><li><code>f_ψ1</code>, <code>f_ψ2</code>: beam element resultant moments</li><li><code>f_F1</code>, <code>f_F2</code>: beam element resultant linear displacements</li><li><code>f_M1</code>, <code>f_M2</code>: beam element resultant angular displacements</li><li><code>f_V</code>: element linear velocity residual</li><li><code>f_Ω</code>: element angular velocity residual</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L358-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_element_residual!" href="#GXBeam.static_element_residual!"><code>GXBeam.static_element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_element_residual!(resid, x, ielem, elem, distributed_loads, 
    point_masses, gvec, force_scaling, icol, irow_e1, irow_p1, irow_e2, irow_p2)</code></pre><p>Compute and add a beam element&#39;s contributions to the residual vector for a static analysis.</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: system residual vector</li><li><code>x</code>: system state vector</li><li><code>ielem</code>: beam element index</li><li><code>elem</code>: beam element</li><li><code>distributed_loads</code>: dictionary with all distributed loads</li><li><code>point_masses</code>: dictionary with all point masses</li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces</li><li><code>icol</code>: starting index for the beam element&#39;s state variables</li><li><code>irow_e1</code>: row index of the first residual equation for the start of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: row index of the first residual equation for the point at the start of the   beam element</li><li><code>irow_e2</code>: row index of the first residual equation for the end of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: row index of the first residual equation for the point at the end of the   beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L400-L424">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_state_element_residual!" href="#GXBeam.steady_state_element_residual!"><code>GXBeam.steady_state_element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_state_element_residual!(resid, x, ielem, elem, distributed_loads, 
    point_masses, gvec, force_scaling, icol, irow_e, irow_e1, irow_p1, irow_e2, irow_p2, 
    x0, v0, ω0, a0, α0)</code></pre><p>Compute and add a beam element&#39;s contributions to the residual vector for a steady state  analysis.</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: system residual vector</li><li><code>x</code>: current state vector</li><li><code>ielem</code>: beam element index</li><li><code>elem</code>: beam element</li><li><code>distributed_loads</code>: dictionary with all distributed loads</li><li><code>point_masses</code>: dictionary with all point masses</li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces</li><li><code>icol</code>: starting index for the beam&#39;s state variables</li><li><code>irow_e1</code>: row index of the first residual equation for the start of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: row index of the first residual equation for the point at the start of the   beam element</li><li><code>irow_e2</code>: row index of the first residual equation for the end of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: row index of the first residual equation for the point at the end of the   beam element</li><li><code>x0</code>: body frame origin (for the current time step)</li><li><code>v0</code>: body frame linear velocity (for the current time step)</li><li><code>ω0</code>: body frame angular velocity (for the current time step)</li><li><code>a0</code>: body frame linear acceleration (for the current time step)</li><li><code>α0</code>: body frame angular acceleration (for the current time step)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L494-L525">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_condition_element_residual!" href="#GXBeam.initial_condition_element_residual!"><code>GXBeam.initial_condition_element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_condition_element_residual!(resid, x, ielem, elem, distributed_loads, 
    point_masses, gvec, force_scaling, icol, irow_e, irow_e1, irow_p1, irow_e2, 
    irow_p2, x0, v0, ω0, a0, α0, u0, θ0, udot0, θdot0)</code></pre><p>Compute and add a beam element&#39;s contributions to the residual vector for an initial  condition analysis.</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: system residual vector</li><li><code>x</code>: current state vector</li><li><code>ielem</code>: beam element index</li><li><code>elem</code>: beam element</li><li><code>distributed_loads</code>: dictionary with all distributed loads</li><li><code>point_masses</code>: dictionary with all point masses</li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces</li><li><code>icol</code>: starting index for the beam&#39;s state variables</li><li><code>irow_e1</code>: row index of the first residual equation for the start of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: row index of the first residual equation for the point at the start of the   beam element</li><li><code>irow_e2</code>: row index of the first residual equation for the end of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: row index of the first residual equation for the point at the end of the   beam element</li><li><code>x0</code>: body frame origin (for the current time step)</li><li><code>v0</code>: body frame linear velocity (for the current time step)</li><li><code>ω0</code>: body frame angular velocity (for the current time step)</li><li><code>a0</code>: body frame linear acceleration (for the current time step)</li><li><code>α0</code>: body frame angular acceleration (for the current time step)</li><li><code>u0</code>: initial linear deflections for the beam element</li><li><code>θ0</code>: initial angular deflections for the beam element</li><li><code>udot0</code>: initial linear deflection rates for the beam element</li><li><code>θdot0</code>: initial angular deflection rates for the beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L609-L644">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_element_residual!" href="#GXBeam.dynamic_element_residual!"><code>GXBeam.dynamic_element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_element_residual!(resid, x, ielem, elem, distributed_loads, point_masses, gvec,
    force_scaling, icol, irow_e, irow_e1, irow_p1, irow_e2, irow_p2, x0, v0, ω0, a0, α0,
    udot, θdot, Vdot, Ωdot)</code></pre><p>Compute and add a beam element&#39;s contributions to the residual vector for a general dynamic  analysis.</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: system residual vector</li><li><code>x</code>: current state vector</li><li><code>ielem</code>: beam element index</li><li><code>elem</code>: beam element</li><li><code>distributed_loads</code>: dictionary with all distributed loads</li><li><code>point_masses</code>: dictionary with all point masses</li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces</li><li><code>icol</code>: starting index for the beam&#39;s state variables</li><li><code>irow_e1</code>: row index of the first residual equation for the start of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: row index of the first residual equation for the point at the start of the   beam element</li><li><code>irow_e2</code>: row index of the first residual equation for the end of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: row index of the first residual equation for the point at the end of the   beam element</li><li><code>x0</code>: body frame origin (for the current time step)</li><li><code>v0</code>: body frame linear velocity (for the current time step)</li><li><code>ω0</code>: body frame angular velocity (for the current time step)</li><li><code>a0</code>: body frame linear acceleration (for the current time step)</li><li><code>α0</code>: body frame angular acceleration (for the current time step)</li><li><code>udot</code>: linear deflection rates for the beam element</li><li><code>θdot</code>: angular deflection rates for the beam element</li><li><code>Vdot</code>: linear velocity rates for the beam element</li><li><code>Ωdot</code>: angular velocity rates for the beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L880-L915">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.newmark_element_residual!" href="#GXBeam.newmark_element_residual!"><code>GXBeam.newmark_element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newmark_element_residual!(resid, x, ielem, elem, distributed_loads, point_masses, gvec,
    force_scaling, icol, irow_e, irow_e1, irow_p1, irow_e2, irow_p2, x0, v0, ω0, a0, α0, 
    udot_init, θdot_init, Vdot_init, Ωdot_init, dt)</code></pre><p>Compute and add a beam element&#39;s contributions to the residual vector for a Newmark scheme  time-marching analysis.</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: system residual vector</li><li><code>x</code>: current state vector</li><li><code>ielem</code>: beam element index</li><li><code>elem</code>: beam element</li><li><code>distributed_loads</code>: dictionary with all distributed loads</li><li><code>point_masses</code>: dictionary with all point masses</li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces</li><li><code>icol</code>: starting index for the beam&#39;s state variables</li><li><code>irow_e1</code>: row index of the first residual equation for the start of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: row index of the first residual equation for the point at the start of the   beam element</li><li><code>irow_e2</code>: row index of the first residual equation for the end of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: row index of the first residual equation for the point at the end of the   beam element</li><li><code>x0</code>: body frame origin (for the current time step)</li><li><code>v0</code>: body frame linear velocity (for the current time step)</li><li><code>ω0</code>: body frame angular velocity (for the current time step)</li><li><code>a0</code>: body frame linear acceleration (for the current time step)</li><li><code>α0</code>: body frame angular acceleration (for the current time step)</li><li><code>udot_init</code>: <code>2/dt*u + udot</code> for the beam element from the previous time step</li><li><code>θdot_init</code>: <code>2/dt*θ + θdot</code> for the beam element from the previous time step</li><li><code>Vdot_init</code>: <code>2/dt*V + Vdot</code> for the beam element from the previous time step</li><li><code>Ωdot_init</code>: <code>2/dt*Ω + Ωdot</code> for the beam element from the previous time step</li><li><code>dt</code>: time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L741-L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_element_jacobian_equations" href="#GXBeam.static_element_jacobian_equations"><code>GXBeam.static_element_jacobian_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_element_jacobian_equations(ΔL, S11, S12, S21, S22, Cab, CtCab, θ, F, M, γ, κ, 
    f1_θ, f2_θ, m1_θ, m2_θ, Ct_θ1, Ct_θ2, Ct_θ3)</code></pre><p>Calculate the derivatives of the element resultants with respect to the state variables for  a static analysis.</p><p><strong>Arguments:</strong></p><ul><li><code>ΔL</code>: beam element length</li><li><code>S11, S12, S21, S22</code>: beam element compliance matrix, divided into submatrices</li><li><code>Cab</code>: transformation matrix from the undeformed beam element frame to the body frame</li><li><code>CtCab</code>: transformation matrix from the deformed beam element frame to the body frame</li><li><code>θ</code>: rotation variables for the element</li><li><code>F</code>: Force variables for the elemen</li><li><code>M</code>: Moment variables for the element [M1, M2, M3]</li><li><code>γ</code>: Engineering strains in the element [γ11, 2γ12, 2γ13]</li><li><code>κ</code>: Curvatures in the element [κ1, κ2, κ3]</li><li><code>f1_θ</code>: Derivative of <code>f1</code> w.r.t <code>θ</code> </li><li><code>f2_θ</code>: Derivative of <code>f2</code> w.r.t <code>θ</code> </li><li><code>m1_θ</code>: Derivative of <code>m1</code> w.r.t <code>θ</code> </li><li><code>m2_θ</code>: Derivative of <code>m2</code> w.r.t <code>θ</code> </li><li><code>Ct_θ1</code>: Derivative of <code>C&#39;</code> w.r.t. <code>θ[1]</code></li><li><code>Ct_θ2</code>: Derivative of <code>C&#39;</code> w.r.t. <code>θ[2]</code></li><li><code>Ct_θ3</code>: Derivative of <code>C&#39;</code> w.r.t. <code>θ[3]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L1012-L1036">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_condition_element_jacobian_equations" href="#GXBeam.initial_condition_element_jacobian_equations"><code>GXBeam.initial_condition_element_jacobian_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_condition_element_jacobian_equations(ΔL, S11, S12, S21, S22, 
    mass11, mass12, mass21, mass22, Cab, CtCab, CtCabdot, θ, F, γ, V, P, ω)</code></pre><p>Calculate the derivatives of the element resultants with respect to the state variables for  an initial condition analysis.</p><p><strong>Arguments:</strong></p><ul><li><code>ΔL</code>: beam element length</li><li><code>S11, S12, S21, S22</code>: beam element compliance matrix, divided into submatrices</li><li><code>mass11, mass12, mass21, mass22</code>: beam element mass matrix, divided into submatrices</li><li><code>Cab</code>: transformation matrix from the undeformed beam element frame to the body frame</li><li><code>CtCab</code>: transformation matrix from the deformed beam element frame to the body frame</li><li><code>CtCabdot</code>: time derivative of <code>CtCab</code></li><li><code>θ</code>: angular displacement</li><li><code>F</code>: internal force</li><li><code>γ</code>: engineering strain</li><li><code>V</code>: linear velocity</li><li><code>P</code>: linear momentum</li><li><code>ω</code>: angular velocity caused by body frame velocity</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L1237-L1257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_state_element_jacobian_equations" href="#GXBeam.steady_state_element_jacobian_equations"><code>GXBeam.steady_state_element_jacobian_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_state_element_jacobian_equations(ΔL, S11, S12, S21, S22, 
    mass11, mass12, mass21, mass22, Cab, CtCab, θ, F, M, γ, κ, V, P, H, ω, f1_u, f2_u, 
    m1_u, m2_u, f1_θ, f2_θ, m1_θ, m2_θ, C_θ1, C_θ2, C_θ3, Ct_θ1, Ct_θ2, Ct_θ3)</code></pre><p>Calculate the derivatives of the element resultants with respect to the state variables for  a steady state analysis.</p><p><strong>Arguments:</strong></p><ul><li><code>ΔL</code>: length</li><li><code>S11, S12, S21, S22</code>: beam element compliance matrix, divided into submatrices</li><li><code>mass11, mass12, mass21, mass22</code>: beam element mass matrix, divided into submatrices</li><li><code>Cab</code>: transformation matrix from the undeformed beam element frame to the body frame</li><li><code>CtCab</code>: transformation matrix from the deformed beam element frame to the body frame</li><li><code>θ</code>: angular displacement</li><li><code>F</code>: internal force</li><li><code>M</code>: internal moment</li><li><code>γ</code>: engineering strain</li><li><code>κ</code>: curvature</li><li><code>V</code>: linear velocity</li><li><code>P</code>: linear momentum</li><li><code>H</code>: angular momentum</li><li><code>ω</code>: angular velocity caused by body frame velocity</li><li><code>f1_u</code>: Derivative of <code>f1</code> w.r.t <code>u</code> </li><li><code>f2_u</code>: Derivative of <code>f2</code> w.r.t <code>u</code> </li><li><code>m1_u</code>: Derivative of <code>m1</code> w.r.t <code>u</code> </li><li><code>m2_u</code>: Derivative of <code>m2</code> w.r.t <code>u</code> </li><li><code>f1_θ</code>: Derivative of <code>f1</code> w.r.t <code>θ</code> </li><li><code>f2_θ</code>: Derivative of <code>f2</code> w.r.t <code>θ</code> </li><li><code>m1_θ</code>: Derivative of <code>m1</code> w.r.t <code>θ</code> </li><li><code>m2_θ</code>: Derivative of <code>m2</code> w.r.t <code>θ</code> </li><li><code>C_θ1</code>: Derivative of <code>C</code> w.r.t. <code>θ[1]</code></li><li><code>C_θ2</code>: Derivative of <code>C</code> w.r.t. <code>θ[2]</code></li><li><code>C_θ3</code>: Derivative of <code>C</code> w.r.t. <code>θ[3]</code></li><li><code>Ct_θ1</code>: Derivative of <code>C&#39;</code> w.r.t. <code>θ[1]</code> (transpose of <code>C_θ1</code>)</li><li><code>Ct_θ2</code>: Derivative of <code>C&#39;</code> w.r.t. <code>θ[2]</code> (transpose of <code>C_θ2</code>)</li><li><code>Ct_θ3</code>: Derivative of <code>C&#39;</code> w.r.t. <code>θ[3]</code> (transpose of <code>C_θ3</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L1124-L1161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.newmark_element_jacobian_equations" href="#GXBeam.newmark_element_jacobian_equations"><code>GXBeam.newmark_element_jacobian_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newmark_element_jacobian_equations(ΔL, S11, S12, S21, S22, mass11, mass12, 
    mass21, mass22, Cab, CtCab, CtCabdot, θ, F, M, γ, κ, V, P, H, θdot, Pdot, Hdot, ω, 
    dt, f1_u, f2_u, m1_u, m2_u, C_θ1, C_θ2, C_θ3, Ct_θ1, Ct_θ2, Ct_θ3, Ctdot_θ1, 
    Ctdot_θ2, Ctdot_θ3, Ctdot_θdot1, Ctdot_θdot2, Ctdot_θdot3)</code></pre><p>Calculate the derivatives of the element resultants with respect to the state variables for  an Newmark scheme time-marching analysis.</p><p><strong>Arguments:</strong></p><ul><li><code>ΔL</code>: length</li><li><code>S11, S12, S21, S22</code>: beam element compliance matrix, divided into submatrices</li><li><code>mass11, mass12, mass21, mass22</code>: beam element mass matrix, divided into submatrices</li><li><code>Cab</code>: transformation matrix from the undeformed beam element frame to the body frame</li><li><code>CtCab</code>: transformation matrix from the deformed beam element frame to the body frame</li><li><code>CtCabdot</code>: time derivative of <code>CtCab</code></li><li><code>θ</code>: angular displacement</li><li><code>F</code>: internal force</li><li><code>M</code>: internal moment</li><li><code>γ</code>: engineering strain</li><li><code>κ</code>: curvature</li><li><code>V</code>: linear velocity</li><li><code>P</code>: linear momentum</li><li><code>H</code>: angular momentum</li><li><code>θdot</code>: angular displacement rate</li><li><code>Pdot</code>: linear momentum rate</li><li><code>Hdot</code>: angular momentum rate</li><li><code>ω</code>: angular velocity caused by body frame velocity</li><li><code>dt</code>: time step size</li><li><code>C_θ1</code>: Derivative of <code>C</code> w.r.t. <code>θ[1]</code></li><li><code>C_θ2</code>: Derivative of <code>C</code> w.r.t. <code>θ[2]</code></li><li><code>C_θ3</code>: Derivative of <code>C</code> w.r.t. <code>θ[3]</code></li><li><code>Ct_θ1</code>: Derivative of <code>C&#39;</code> w.r.t. <code>θ[1]</code> (transpose of <code>C_θ1</code>)</li><li><code>Ct_θ2</code>: Derivative of <code>C&#39;</code> w.r.t. <code>θ[2]</code> (transpose of <code>C_θ2</code>)</li><li><code>Ct_θ3</code>: Derivative of <code>C&#39;</code> w.r.t. <code>θ[3]</code> (transpose of <code>C_θ3</code>)</li><li><code>Ctdot_θ1</code>: Derivative of <code>Cdot&#39;</code> w.r.t. <code>θ[1]</code></li><li><code>Ctdot_θ2</code>: Derivative of <code>Cdot&#39;</code> w.r.t. <code>θ[2]</code></li><li><code>Ctdot_θ3</code>: Derivative of <code>Cdot&#39;</code> w.r.t. <code>θ[3]</code></li><li><code>Ctdot_θdot1</code>: Derivative of <code>Cdot&#39;</code> w.r.t. <code>θdot[1]</code></li><li><code>Ctdot_θdot2</code>: Derivative of <code>Cdot&#39;</code> w.r.t. <code>θdot[2]</code></li><li><code>Ctdot_θdot3</code>: Derivative of <code>Cdot&#39;</code> w.r.t. <code>θdot[3]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L1365-L1406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_element_jacobian_equations" href="#GXBeam.dynamic_element_jacobian_equations"><code>GXBeam.dynamic_element_jacobian_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_element_jacobian_equations(ΔL, S11, S12, S21, S22, mass11, mass12, 
    mass21, mass22, Cab, CtCab, CtCabdot, θ, F, M, γ, κ, V, P, H, θdot, Pdot, Hdot, ω, 
    f1_u, f2_u, m1_u, m2_u, f1_θ, f2_θ, m1_θ, m2_θ, 
    C_θ1, C_θ2, C_θ3, Ct_θ1, Ct_θ2, Ct_θ3, Ctdot_θ1, Ctdot_θ2, Ctdot_θ3)</code></pre><p>Calculate the derivatives of the element resultants with respect to the state variables for  an Newmark scheme time-marching analysis.</p><p><strong>Arguments:</strong></p><ul><li><code>ΔL</code>: length</li><li><code>S11, S12, S21, S22</code>: beam element compliance matrix, divided into submatrices</li><li><code>mass11, mass12, mass21, mass22</code>: beam element mass matrix, divided into submatrices</li><li><code>Cab</code>: transformation matrix from the undeformed beam element frame to the body frame</li><li><code>CtCab</code>: transformation matrix from the deformed beam element frame to the body frame</li><li><code>CtCabdot</code>: time derivative of <code>CtCab</code></li><li><code>θ</code>: angular displacement</li><li><code>F</code>: internal force</li><li><code>M</code>: internal moment</li><li><code>γ</code>: engineering strain</li><li><code>κ</code>: curvature</li><li><code>V</code>: linear velocity</li><li><code>P</code>: linear momentum</li><li><code>H</code>: angular momentum</li><li><code>θdot</code>: angular displacement rate</li><li><code>Pdot</code>: linear momentum rate</li><li><code>Hdot</code>: angular momentum rate</li><li><code>ω</code>: angular velocity caused by body frame velocity</li><li><code>f1_u</code>: Derivative of <code>f1</code> w.r.t <code>u</code> </li><li><code>f2_u</code>: Derivative of <code>f2</code> w.r.t <code>u</code> </li><li><code>m1_u</code>: Derivative of <code>m1</code> w.r.t <code>u</code> </li><li><code>m2_u</code>: Derivative of <code>m2</code> w.r.t <code>u</code> </li><li><code>f1_θ</code>: Derivative of <code>f1</code> w.r.t <code>θ</code> </li><li><code>f2_θ</code>: Derivative of <code>f2</code> w.r.t <code>θ</code> </li><li><code>m1_θ</code>: Derivative of <code>m1</code> w.r.t <code>θ</code> </li><li><code>m2_θ</code>: Derivative of <code>m2</code> w.r.t <code>θ</code> </li><li><code>C_θ1</code>: Derivative of <code>C</code> w.r.t. <code>θ[1]</code></li><li><code>C_θ2</code>: Derivative of <code>C</code> w.r.t. <code>θ[2]</code></li><li><code>C_θ3</code>: Derivative of <code>C</code> w.r.t. <code>θ[3]</code></li><li><code>Ct_θ1</code>: Derivative of <code>C&#39;</code> w.r.t. <code>θ[1]</code> (transpose of <code>C_θ1</code>)</li><li><code>Ct_θ2</code>: Derivative of <code>C&#39;</code> w.r.t. <code>θ[2]</code> (transpose of <code>C_θ2</code>)</li><li><code>Ct_θ3</code>: Derivative of <code>C&#39;</code> w.r.t. <code>θ[3]</code> (transpose of <code>C_θ3</code>)</li><li><code>Ctdot_θ1</code>: Derivative of <code>Cdot&#39;</code> w.r.t. <code>θ[1]</code></li><li><code>Ctdot_θ2</code>: Derivative of <code>Cdot&#39;</code> w.r.t. <code>θ[2]</code></li><li><code>Ctdot_θ3</code>: Derivative of <code>Cdot&#39;</code> w.r.t. <code>θ[3]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L1479-L1524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_insert_element_jacobian!" href="#GXBeam.static_insert_element_jacobian!"><code>GXBeam.static_insert_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_insert_element_jacobian!(jacob, force_scaling, irow_e1,
    irow_p1, irow_e2, irow_p2, icol,
    f_u1_u, f_u2_u, f_u1_θ, f_u2_θ, f_u1_F, f_u2_F,
    f_ψ1_u, f_ψ2_u, f_ψ1_θ, f_ψ2_θ, f_ψ1_F, f_ψ2_F, f_ψ1_M, f_ψ2_M,
    f_F1_u, f_F2_u, f_F1_θ, f_F2_θ, f_F1_F, f_F2_F, f_F1_M, f_F2_M,
    f_M1_θ, f_M2_θ, f_M1_F, f_M2_F, f_M1_M, f_M2_M)</code></pre><p>Insert the the beam element jacobian entries into the jacobian matrix for a static analysis</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: System jacobian matrix</li><li><code>force_scaling</code>: Scaling parameter for forces</li><li><code>irow_e1</code>: row index of the first residual equation for the start of the beam element (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: row index of the first residual equation for the point at the start of the  beam element</li><li><code>irow_e2</code>: row index of the first residual equation for the end of the beam element (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: row index of the first residual equation for the point at the end of the  beam element</li><li><code>icol</code>: Row/Column index corresponding to the first beam state variable</li></ul><p>All other arguments use the following naming convention:</p><ul><li><code>f_y_x</code>: Jacobian of resultant <code>y</code> with respect to state variable <code>x</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L1586-L1611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_condition_insert_element_jacobian!" href="#GXBeam.initial_condition_insert_element_jacobian!"><code>GXBeam.initial_condition_insert_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_condition_insert_element_jacobian!(jacob, force_scaling,
    irow_e, irow_e1, irow_p1, irow_e2, irow_p2, icol,
    f_u1_Vdot, f_u2_Vdot, f_u1_Ωdot, f_u2_Ωdot, 
    f_u1_F, f_u2_F, f_u1_V, f_u2_V, f_u1_Ω, f_u2_Ω,
    f_ψ1_Vdot, f_ψ2_Vdot, f_ψ1_Ωdot, f_ψ2_Ωdot, 
    f_ψ1_F, f_ψ2_F, f_ψ1_M, f_ψ2_M, f_ψ1_V, f_ψ2_V, f_ψ1_Ω, f_ψ2_Ω,
    f_F1_F, f_F2_F, f_F1_M, f_F2_M,
    f_M1_F, f_M2_F, f_M1_M, f_M2_M,
    f_V_V, f_Ω_Ω)</code></pre><p>Insert the the beam element jacobian entries into the jacobian matrix for an initial  condition analysis</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: System jacobian matrix</li><li><code>force_scaling</code>: Scaling parameter for forces</li><li><code>irow_e1</code>: row index of the first residual equation for the start of the beam element (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: row index of the first residual equation for the point at the start of the  beam element</li><li><code>irow_e2</code>: row index of the first residual equation for the end of the beam element (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: row index of the first residual equation for the point at the end of the  beam element</li><li><code>icol</code>: Row/Column index corresponding to the first beam state variable</li></ul><p>All other arguments use the following naming convention:</p><ul><li><code>f_y_x</code>: Jacobian of element equation <code>y</code> with respect to state variable <code>x</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L1672-L1701">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_insert_element_jacobian!" href="#GXBeam.dynamic_insert_element_jacobian!"><code>GXBeam.dynamic_insert_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_insert_element_jacobian!(jacob, force_scaling, irow_e,
    irow_e1, irow_p1, irow_e2, irow_p2, icol,
    f_u1_u, f_u2_u, f_u1_θ, f_u2_θ, f_u1_F, f_u2_F, f_u1_V, f_u2_V, f_u1_Ω, f_u2_Ω,
    f_ψ1_u, f_ψ2_u, f_ψ1_θ, f_ψ2_θ, f_ψ1_F, f_ψ2_F, f_ψ1_M, f_ψ2_M, 
    f_ψ1_V, f_ψ2_V, f_ψ1_Ω, f_ψ2_Ω,
    f_F1_u, f_F2_u, f_F1_θ, f_F2_θ, f_F1_F, f_F2_F, f_F1_M, f_F2_M,
    f_M1_θ, f_M2_θ, f_M1_F, f_M2_F, f_M1_M, f_M2_M,
    f_V_u, f_V_θ, f_V_V,
    f_Ω_θ, f_Ω_Ω)</code></pre><p>Insert the the beam element jacobian entries into the jacobian matrix for a dynamic analysis</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: system jacobian matrix</li><li><code>force_scaling</code>: scaling parameter for forces</li><li><code>irow_e</code>: row index of the first linear/angular velocity residual for this element</li><li><code>irow_e1</code>: row index of the first residual equation for the start of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: row index of the first residual equation for the point at the start of the   beam element</li><li><code>irow_e2</code>: row index of the first residual equation for the end of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: row index of the first residual equation for the point at the end of the   beam element</li><li><code>icol</code>: row/column index corresponding to the first beam state variable</li></ul><p>All other arguments use the following naming convention:</p><ul><li><code>f_y_x</code>: jacobian of element equation <code>y</code> with respect to state variable <code>x</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L1772-L1801">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_element_jacobian!" href="#GXBeam.static_element_jacobian!"><code>GXBeam.static_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_element_jacobian!(jacob, x, ielem, elem, distributed_loads, 
    point_masses, gvec, force_scaling, icol, irow_e1, irow_p1, irow_e2, irow_p2)</code></pre><p>Adds a beam element&#39;s contributions to the system jacobian matrix for a static analysis.</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: System jacobian matrix</li><li><code>x</code>: current state vector</li><li><code>ielem</code>: beam element index</li><li><code>elem</code>: beam element</li><li><code>distributed_loads</code>: dictionary with all distributed loads</li><li><code>point_masses</code>: dictionary with all point masses</li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces/moments</li><li><code>icol</code>: starting index for the beam&#39;s state variables</li><li><code>irow_e1</code>: row index of the first residual equation for the start of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: row index of the first residual equation for the point at the start of the   beam element</li><li><code>irow_e2</code>: row index of the first residual equation for the end of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: row index of the first residual equation for the point at the end of the   beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L1842-L1866">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_state_element_jacobian!" href="#GXBeam.steady_state_element_jacobian!"><code>GXBeam.steady_state_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_state_element_jacobian!(jacob, x, ielem, elem, distributed_loads, point_masses, 
    gvec, force_scaling, icol, irow_e, irow_e1, irow_p1, irow_e2, irow_p2, x0, v0, ω0, 
    a0, α0)</code></pre><p>Adds a beam element&#39;s contributions to the system jacobian matrix for a steady state  analysis.</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: System jacobian matrix</li><li><code>x</code>: current state vector</li><li><code>ielem</code>: beam element index</li><li><code>elem</code>: beam element</li><li><code>distributed_loads</code>: dictionary with all distributed loads</li><li><code>point_masses</code>: dictionary with all point masses</li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces/moments</li><li><code>icol</code>: starting index for the beam&#39;s state variables</li><li><code>irow_e1</code>: row index of the first residual equation for the start of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: row index of the first residual equation for the point at the start of the   beam element</li><li><code>irow_e2</code>: row index of the first residual equation for the end of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: row index of the first residual equation for the point at the end of the   beam element</li><li><code>x0</code>: Body frame origin (for the current time step)</li><li><code>v0</code>: Body frame linear velocity (for the current time step)</li><li><code>ω0</code>: Body frame angular velocity (for the current time step)</li><li><code>a0</code>: Body frame linear acceleration (for the current time step)</li><li><code>α0</code>: Body frame angular acceleration (for the current time step)</li></ul><pre><code class="nohighlight hljs"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L1946-L1977">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_condition_element_jacobian!" href="#GXBeam.initial_condition_element_jacobian!"><code>GXBeam.initial_condition_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_condition_element_jacobian!(jacob, x, ielem, elem, distributed_loads, 
    point_masses, gvec, force_scaling, icol, irow_e, irow_e1, irow_p1, irow_e2, 
    irow_p2, x0, v0, ω0, a0, α0, u0, θ0, udot0, θdot0)</code></pre><p>Adds a beam element&#39;s contributions to the system jacobian matrix for an initial conditions  analysis.</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: System jacobian matrix</li><li><code>x</code>: current state vector</li><li><code>ielem</code>: beam element index</li><li><code>elem</code>: beam element</li><li><code>distributed_loads</code>: dictionary with all distributed loads</li><li><code>point_masses</code>: dictionary with all point masses</li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces/moments</li><li><code>icol</code>: starting index for the beam&#39;s state variables</li><li><code>irow_e1</code>: row index of the first residual equation for the start of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: row index of the first residual equation for the point at the start of the   beam element</li><li><code>irow_e2</code>: row index of the first residual equation for the end of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: row index of the first residual equation for the point at the end of the   beam element</li><li><code>x0</code>: Body frame origin (for the current time step)</li><li><code>v0</code>: Body frame linear velocity (for the current time step)</li><li><code>ω0</code>: Body frame angular velocity (for the current time step)</li><li><code>a0</code>: Body frame linear acceleration (for the current time step)</li><li><code>α0</code>: Body frame angular acceleration (for the current time step)</li><li><code>u</code>: initial deflection variables for the beam element</li><li><code>θ</code>: initial rotation variables for the beam element</li><li><code>udot</code>: initial time derivative of u for the beam element</li><li><code>θdot</code>: initial time derivative of θ for the beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L2077-L2112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.newmark_element_jacobian!" href="#GXBeam.newmark_element_jacobian!"><code>GXBeam.newmark_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newmark_element_jacobian!(jacob, x, ielem, elem, distributed_loads, point_masses, gvec,
    force_scaling, icol, irow_e, irow_e1, irow_p1, irow_e2, irow_p2, x0, v0, ω0, a0, α0,
    udot_init, θdot_init, Vdot_init, Ωdot_init, dt)</code></pre><p>Adds a beam element&#39;s contributions to the system jacobian matrix for a Newmark scheme  time-marching simulation.</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: System jacobian matrix</li><li><code>x</code>: current state vector</li><li><code>ielem</code>: beam element index</li><li><code>elem</code>: beam element</li><li><code>distributed_loads</code>: dictionary with all distributed loads</li><li><code>point_masses</code>: dictionary with all point masses</li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces/moments</li><li><code>icol</code>: starting index for the beam&#39;s state variables</li><li><code>irow_e1</code>: row index of the first residual equation for the start of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: row index of the first residual equation for the point at the start of the   beam element</li><li><code>irow_e2</code>: row index of the first residual equation for the end of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: row index of the first residual equation for the point at the end of the   beam element</li><li><code>x0</code>: Body frame origin (for the current time step)</li><li><code>v0</code>: Body frame linear velocity (for the current time step)</li><li><code>ω0</code>: Body frame angular velocity (for the current time step)</li><li><code>a0</code>: Body frame linear acceleration (for the current time step)</li><li><code>α0</code>: Body frame angular acceleration (for the current time step)</li><li><code>udot_init</code>: <code>2/dt*u + udot</code> for the beam element from the previous time step</li><li><code>θdot_init</code>: <code>2/dt*θ + θdot</code> for the beam element from the previous time step</li><li><code>Vdot_init</code>: <code>2/dt*V + Vdot</code> for the beam element from the previous time step</li><li><code>Ωdot_init</code>: <code>2/dt*Ω + Ωdot</code> for the beam element from the previous time step</li><li><code>dt</code>: time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L2191-L2227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_element_jacobian!" href="#GXBeam.dynamic_element_jacobian!"><code>GXBeam.dynamic_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_element_jacobian!(jacob, x, ielem, elem, distributed_loads, point_masses, gvec,
    force_scaling, icol, irow_e, irow_e1, irow_p1, irow_e2, irow_p2, x0, v0, ω0, a0, α0,
    udot, θdot, Vdot, Ωdot)</code></pre><p>Adds a beam element&#39;s contributions to the system jacobian matrix for a general dynamic  simulation.</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: System jacobian matrix</li><li><code>x</code>: current state vector</li><li><code>ielem</code>: beam element index</li><li><code>elem</code>: beam element</li><li><code>distributed_loads</code>: dictionary with all distributed loads</li><li><code>point_masses</code>: dictionary with all point masses</li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces/moments</li><li><code>icol</code>: starting index for the beam&#39;s state variables</li><li><code>irow_e1</code>: row index of the first residual equation for the start of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: row index of the first residual equation for the point at the start of the   beam element</li><li><code>irow_e2</code>: row index of the first residual equation for the end of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: row index of the first residual equation for the point at the end of the   beam element</li><li><code>x0</code>: Body frame origin (for the current time step)</li><li><code>v0</code>: Body frame linear velocity (for the current time step)</li><li><code>ω0</code>: Body frame angular velocity (for the current time step)</li><li><code>a0</code>: Body frame linear acceleration (for the current time step)</li><li><code>α0</code>: Body frame angular acceleration (for the current time step)</li><li><code>udot_init</code>: <code>2/dt*u + udot</code> for the beam element from the previous time step</li><li><code>θdot_init</code>: <code>2/dt*θ + θdot</code> for the beam element from the previous time step</li><li><code>Vdot_init</code>: <code>2/dt*V + Vdot</code> for the beam element from the previous time step</li><li><code>Ωdot_init</code>: <code>2/dt*Ω + Ωdot</code> for the beam element from the previous time step</li><li><code>dt</code>: time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L2351-L2387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_mass_matrix_equations" href="#GXBeam.element_mass_matrix_equations"><code>GXBeam.element_mass_matrix_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">element_mass_matrix_equations(mass11, mass12, mass21, mass22, Cab, 
    CtCab, θ, P, H, Ctdot_θdot1, Ctdot_θdot2, Ctdot_θdot3)</code></pre><p>Calculate the derivatives of the element resultants with respect to the state rates.</p><p><strong>Arguments:</strong></p><ul><li><code>mass11, mass12, mass21, mass22</code>: beam element mass matrix, divided into submatrices</li><li><code>Cab</code>: transformation matrix from the undeformed beam element frame to the body frame</li><li><code>CtCab</code>: transformation matrix from the deformed beam element frame to the body frame</li><li><code>θ</code>: angular displacement</li><li><code>P</code>: linear momentum</li><li><code>H</code>: angular momentum</li><li><code>Ctdot_θdot1</code>: Derivative of <code>Cdot&#39;</code> w.r.t. <code>θdot[1]</code></li><li><code>Ctdot_θdot2</code>: Derivative of <code>Cdot&#39;</code> w.r.t. <code>θdot[2]</code></li><li><code>Ctdot_θdot3</code>: Derivative of <code>Cdot&#39;</code> w.r.t. <code>θdot[3]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L2503-L2519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.insert_element_mass_matrix!" href="#GXBeam.insert_element_mass_matrix!"><code>GXBeam.insert_element_mass_matrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_element_mass_matrix!(jacob, force_scaling, irow_e, irow_p1, 
    irow_p2, icol, 
    f_u1_θdot, f_u2_θdot, f_u1_Vdot, f_u2_Vdot, f_u1_Ωdot, f_u2_Ωdot,
    f_ψ1_θdot, f_ψ2_θdot, f_ψ1_Vdot, f_ψ2_Vdot, f_ψ1_Ωdot, f_ψ2_Ωdot,
    f_V_udot, f_Ω_θdot)</code></pre><p>Insert the beam element&#39;s contributions into the &quot;mass matrix&quot;: the jacobian of the residual equations with respect to the state variable rates</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: System mass matrix</li><li><code>force_scaling</code>: Scaling parameter for forces/moments</li><li><code>irow_e</code>: row index of the first linear/angular velocity residual for this element</li><li><code>irow_p1</code>: row index of the first residual equation for the point at the start of the   beam element</li><li><code>irow_p2</code>: row index of the first residual equation for the point at the end of the   beam element</li><li><code>icol</code>: Row/Column index corresponding to the first beam state variable</li></ul><p>All other arguments use the following naming convention:</p><ul><li><code>f_y_x</code>: Jacobian of element equation &quot;y&quot; with respect to state variable &quot;x&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L2557-L2579">source</a></section><section><div><pre><code class="nohighlight hljs">insert_element_mass_matrix!(jacob, gamma, force_scaling, irow_e,
    irow_p1, irow_p2, icol, 
    f_u1_θdot, f_u2_θdot, f_u1_Vdot, f_u2_Vdot, f_u1_Ωdot, f_u2_Ωdot,
    f_ψ1_θdot, f_ψ2_θdot, f_ψ1_Vdot, f_ψ2_Vdot, f_ψ1_Ωdot, f_ψ2_Ωdot,
    f_V_udot, f_Ω_θdot)</code></pre><p>Add the beam element&#39;s mass matrix to the system jacobian matrix <code>jacob</code>, scaled by the scaling parameter <code>gamma</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L2609-L2618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_mass_matrix!" href="#GXBeam.element_mass_matrix!"><code>GXBeam.element_mass_matrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">element_mass_matrix!(jacob, x, elem, point_masses, force_scaling, icol,
    irow_e, irow_e1, irow_p1, irow_e2, irow_p2)</code></pre><p>Insert the beam element&#39;s contributions to the &quot;mass matrix&quot;: the jacobian of the residual equations with respect to the time derivatives of the state variables</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: system jacobian matrix</li><li><code>x</code>: current state vector</li><li><code>ielem</code>: beam element index</li><li><code>elem</code>: beam element</li><li><code>point_masses</code>: dictionary with all point masses</li><li><code>force_scaling</code>: scaling parameter for forces/moments</li><li><code>icol</code>: starting index for the beam&#39;s state variables</li><li><code>irow_e1</code>: row index of the first residual equation for the start of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: row index of the first residual equation for the point at the start of the   beam element</li><li><code>irow_e2</code>: row index of the first residual equation for the end of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: row index of the first residual equation for the point at the end of the   beam element</li><li><code>gamma</code>: Scaling parameter for scaling mass matrix contribution to <code>jacob</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L2648-L2672">source</a></section><section><div><pre><code class="nohighlight hljs">element_mass_matrix!(jacob, gamma, x, ielem, elem, force_scaling,
    icol, irow_e, irow_e1, irow_p1, irow_e2, irow_p2)</code></pre><p>Add the beam element&#39;s mass matrix to the system jacobian matrix <code>jacob</code>, scaled by the scaling parameter <code>gamma</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/element.jl#L2727-L2733">source</a></section></article><h3 id="Loads"><a class="docs-heading-anchor" href="#Loads">Loads</a><a id="Loads-1"></a><a class="docs-heading-anchor-permalink" href="#Loads" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.acceleration_loads" href="#GXBeam.acceleration_loads"><code>GXBeam.acceleration_loads</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">acceleration_loads(mass11, mass12, mass21, mass22, CtCab, u, a, α)</code></pre><p>Calculate the integrated distributed loads on an element caused by acceleration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/loads.jl#L450-L454">source</a></section></article><h3 id="System"><a class="docs-heading-anchor" href="#System">System</a><a id="System-1"></a><a class="docs-heading-anchor-permalink" href="#System" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.Assembly" href="#GXBeam.Assembly"><code>GXBeam.Assembly</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Assembly{TF, TP&lt;:AbstractVector{&lt;:AbstractVector{TF}},
    TC&lt;:AbstractVector{&lt;:Integer}, TE&lt;:AbstractVector{Element{TF}}}</code></pre><p>Composite type that defines an assembly of connected nonlinear beam elements for analysis.</p><p><strong>Fields</strong></p><ul><li><code>points</code>: Array of all beam element endpoints</li><li><code>start</code>: Array containing point index where each beam element starts</li><li><code>stop</code>: Array containing point index where each beam element stops</li><li><code>elements</code>: Array of <code>Element</code>s</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/assembly.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.curve_triad" href="#GXBeam.curve_triad"><code>GXBeam.curve_triad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">curve_triad(Cab, k, s)
curve_triad(Cab, kkt, ktilde, kn, s)</code></pre><p>Return the transformation matrix at <code>s</code> along the length of the beam given the curvature vector <code>k</code> and the initial transformation matrix <code>Cab</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/assembly.jl#L212-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.curve_coordinates" href="#GXBeam.curve_coordinates"><code>GXBeam.curve_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">curve_coordiantes(r, Cab, k, s)
curve_coordinates(r, Cab, kkt, ktilde, kn, s)</code></pre><p>Return the coordinates at <code>s</code> along the length of the beam given the starting point <code>r</code>, initial transformation matrix <code>Cab</code>, and curvature vector <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/assembly.jl#L223-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.System" href="#GXBeam.System"><code>GXBeam.System</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">System{TF, TV&lt;:AbstractVector{TF}, TM&lt;:AbstractMatrix{TF}}</code></pre><p>Contains the system state, residual vector, and jacobian matrices as well as pointers to be able to access their contents.  Also contains additional storage needed for time domain simulations.</p><p><strong>Fields:</strong></p><ul><li><code>static</code>: Flag indicating whether system matrices are only valid for static analyses</li><li><code>x</code>: State vector</li><li><code>r</code>: Residual vector</li><li><code>K</code>: System jacobian matrix with respect to the state variables</li><li><code>M</code>: System jacobian matrix with respect to the time derivative of the state variables</li><li><code>force_scaling</code>: Scaling for state variables corresponding to forces/moments</li><li><code>irow_point</code>: Row index of first equilibrium equation for each point</li><li><code>irow_elem</code>: Row index of first equation for just this beam element</li><li><code>irow_elem1</code>: Row index of first equation for the left side of each beam</li><li><code>irow_elem2</code>: Row index of first equation for the right side of each beam</li><li><code>icol_point</code>: Row/Column index of first state variable for each point</li><li><code>icol_elem</code>: Row/Column index of first state variable for each beam element</li><li><code>udot</code>: Time derivative of state variable <code>u</code> for each beam element</li><li><code>θdot</code>: Time derivative of state variable <code>θ</code> for each beam element</li><li><code>Vdot</code>: Time derivative of state variable <code>V</code> for each beam element</li><li><code>Ωdot</code>: Time derivative of state variable <code>Ω</code> for each beam element</li><li><code>t</code>: Current system time</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_system_residual!" href="#GXBeam.static_system_residual!"><code>GXBeam.static_system_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_system_residual!(resid, x, assembly, prescribed_conditions, distributed_loads, point_masses, gvec,
    force_scaling, irow_point, irow_elem, irow_elem1, irow_elem2, icol_point, icol_elem)</code></pre><p>Populate the system residual vector <code>resid</code> for a static analysis</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: system residual vector</li><li><code>x</code>: current states of the system</li><li><code>assembly</code>: assembly of nonlinear beam elements</li><li><code>prescribed_conditions</code>: dictionary of prescribed conditions</li><li><code>distributed_loads</code>: dictionary of distributed loads</li><li><code>point_masses</code>: dictionary of point masses </li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces/moments</li><li><code>irow_point</code>: row index of first equilibrium equation for each point</li><li><code>irow_elem</code>: row index of first equation for just this beam element</li><li><code>irow_elem1</code>: row index of first equation for the left side of each beam</li><li><code>irow_elem2</code>: row index of first equation for the right side of each beam</li><li><code>icol_point</code>: column index of first state variable for each point</li><li><code>icol_elem</code>: column index of first state variable for each beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L834-L855">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_condition_system_residual!" href="#GXBeam.initial_condition_system_residual!"><code>GXBeam.initial_condition_system_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_condition_system_residual!(resid, x, assembly, prescribed_conditions, distributed_loads, point_masses, gvec,
    force_scaling, irow_point, irow_elem, irow_elem1, irow_elem2, icol_point, icol_elem,
    x0, v0, ω0, a0, α0, u, θ, udot, θdot)</code></pre><p>Populate the system residual vector <code>resid</code> for an initial conditions analysis.</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: system residual vector</li><li><code>x</code>: current states of the system</li><li><code>assembly</code>: assembly of nonlinear beam elements</li><li><code>prescribed_conditions</code>: dictionary of prescribed conditions</li><li><code>distributed_loads</code>: dictionary of distributed loads</li><li><code>point_masses</code>: dictionary of point masses </li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces/moments</li><li><code>irow_point</code>: row index of first equilibrium equation for each point</li><li><code>irow_elem</code>: row index of first equation for just this beam element</li><li><code>irow_elem1</code>: row index of first equation for the left side of each beam</li><li><code>irow_elem2</code>: row index of first equation for the right side of each beam</li><li><code>icol_point</code>: column index of first state variable for each point</li><li><code>icol_elem</code>: column index of first state variable for each beam element</li><li><code>x0</code>: body frame origin</li><li><code>v0</code>: body frame linear velocity</li><li><code>ω0</code>: body frame angular velocity</li><li><code>a0</code>: body frame linear acceleration</li><li><code>α0</code>: body frame angular acceleration</li><li><code>u</code>: initial linear deflections for each beam element</li><li><code>θ</code>: initial angular deflections for each beam element</li><li><code>udot</code>: initial linear deflection rates for each beam element</li><li><code>θdot</code>: initial angular deflection rates for each beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L964-L995">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_state_system_residual!" href="#GXBeam.steady_state_system_residual!"><code>GXBeam.steady_state_system_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_state_system_residual!(resid, x, assembly, prescribed_conditions, distributed_loads, point_masses, gvec,
    force_scaling, irow_point, irow_elem, irow_elem1, irow_elem2, icol_point, icol_elem,
    x0, v0, ω0, a0, α0)</code></pre><p>Populate the system residual vector <code>resid</code> for a steady state analysis.</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: system residual vector</li><li><code>x</code>: current states of the system</li><li><code>assembly</code>: assembly of nonlinear beam elements</li><li><code>prescribed_conditions</code>: dictionary of prescribed conditions</li><li><code>distributed_loads</code>: dictionary of distributed loads</li><li><code>point_masses</code>: dictionary of point masses </li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces/moments</li><li><code>irow_point</code>: row index of first equilibrium equation for each point</li><li><code>irow_elem</code>: row index of first equation for just this beam element</li><li><code>irow_elem1</code>: row index of first equation for the left side of each beam</li><li><code>irow_elem2</code>: row index of first equation for the right side of each beam</li><li><code>icol_point</code>: column index of first state variable for each point</li><li><code>icol_elem</code>: column index of first state variable for each beam element</li><li><code>x0</code>: body frame origin</li><li><code>v0</code>: body frame linear velocity</li><li><code>ω0</code>: body frame angular velocity</li><li><code>a0</code>: body frame linear acceleration</li><li><code>α0</code>: body frame angular acceleration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L895-L922">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.newmark_system_residual!" href="#GXBeam.newmark_system_residual!"><code>GXBeam.newmark_system_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newmark_system_residual!(resid, x, assembly, prescribed_conditions, distributed_loads, point_masses, gvec,
    force_scaling, irow_point, irow_elem, irow_elem1, irow_elem2, icol_point, icol_elem,
    x0, v0, ω0, a0, α0, udot_init, θdot_init, Vdot_init, Ωdot_init, dt)</code></pre><p>Populate the system residual vector <code>resid</code> for a Newmark scheme time-marching analysis.</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: system residual vector</li><li><code>x</code>: current states of the system</li><li><code>assembly</code>: assembly of nonlinear beam elements</li><li><code>prescribed_conditions</code>: dictionary of prescribed conditions</li><li><code>distributed_loads</code>: dictionary of distributed loads</li><li><code>point_masses</code>: dictionary of point masses </li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces/moments</li><li><code>irow_point</code>: row index of first equilibrium equation for each point</li><li><code>irow_elem</code>: row index of first equation for just this beam element</li><li><code>irow_elem1</code>: row index of first equation for the left side of each beam</li><li><code>irow_elem2</code>: row index of first equation for the right side of each beam</li><li><code>icol_point</code>: column index of first state variable for each point</li><li><code>icol_elem</code>: column index of first state variable for each beam element</li><li><code>x0</code>: body frame origin</li><li><code>v0</code>: body frame linear velocity</li><li><code>ω0</code>: body frame angular velocity</li><li><code>a0</code>: body frame linear acceleration</li><li><code>α0</code>: body frame angular acceleration</li><li><code>udot_init</code>: <code>2/dt*u + udot</code> for each beam element from the previous time step</li><li><code>θdot_init</code>: <code>2/dt*θ + θdot</code> for each beam element from the previous time step</li><li><code>Vdot_init</code>: <code>2/dt*V + Vdot</code> for each beam element from the previous time step</li><li><code>Ωdot_init</code>: <code>2/dt*Ω + Ωdot</code> for each beam element from the previous time step</li><li><code>dt</code>: time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L1038-L1070">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_system_residual!" href="#GXBeam.dynamic_system_residual!"><code>GXBeam.dynamic_system_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_system_residual!(resid, dx, x, assembly, prescribed_conditions, distributed_loads, point_masses, gvec,
    force_scaling, irow_point, irow_elem, irow_elem1, irow_elem2, icol_point, icol_elem,
    x0, v0, ω0, a0, α0)</code></pre><p>Populate the system residual vector <code>resid</code> for a general dynamic system analysis.</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: system residual vector</li><li><code>dx</code>: current state rates of the system</li><li><code>x</code>: current states of the system</li><li><code>assembly</code>: assembly of nonlinear beam elements</li><li><code>prescribed_conditions</code>: dictionary of prescribed conditions</li><li><code>distributed_loads</code>: dictionary of distributed loads</li><li><code>point_masses</code>: dictionary of point masses </li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces/moments</li><li><code>irow_point</code>: row index of first equilibrium equation for each point</li><li><code>irow_elem</code>: row index of first equation for just this beam element</li><li><code>irow_elem1</code>: row index of first equation for the left side of each beam</li><li><code>irow_elem2</code>: row index of first equation for the right side of each beam</li><li><code>icol_point</code>: column index of first state variable for each point</li><li><code>icol_elem</code>: column index of first state variable for each beam element</li><li><code>x0</code>: body frame origin</li><li><code>v0</code>: body frame linear velocity</li><li><code>ω0</code>: body frame angular velocity</li><li><code>a0</code>: body frame linear acceleration</li><li><code>α0</code>: body frame angular acceleration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L1114-L1142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_system_jacobian!" href="#GXBeam.static_system_jacobian!"><code>GXBeam.static_system_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_system_jacobian!(jacob, x, assembly,
    prescribed_conditions, distributed_loads, point_masses, gvec, force_scaling,
    irow_point, irow_elem, irow_elem1, irow_elem2, icol_point, icol_elem)</code></pre><p>Populate the system jacobian matrix <code>jacob</code> for a static analysis.</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: system jacobian matrix</li><li><code>x</code>: current states of the system</li><li><code>assembly</code>: assembly of nonlinear beam elements</li><li><code>prescribed_conditions</code>: dictionary of prescribed conditions</li><li><code>distributed_loads</code>: dictionary of distributed loads</li><li><code>point_masses</code>: dictionary of point masses </li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces/moments</li><li><code>irow_point</code>: row index of first equilibrium equation for each point</li><li><code>irow_elem1</code>: row index of first equation for the left side of each beam</li><li><code>irow_elem2</code>: row index of first equation for the right side of each beam</li><li><code>icol_point</code>: column index of first state variable for each point</li><li><code>icol_elem</code>: column index of first state variable for each beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L1191-L1212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_state_system_jacobian!" href="#GXBeam.steady_state_system_jacobian!"><code>GXBeam.steady_state_system_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_state_system_jacobian!(jacob, x, assembly,
    prescribed_conditions, distributed_loads, point_masses, gvec, force_scaling,
    irow_point, irow_elem, irow_elem1, irow_elem2, icol_point, icol_elem,
    x0, v0, ω0, a0, α0)</code></pre><p>Populate the system jacobian matrix <code>jacob</code> for a steady state analysis.</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: system jacobian matrix</li><li><code>x</code>: current states of the system</li><li><code>assembly</code>: assembly of nonlinear beam elements</li><li><code>prescribed_conditions</code>: dictionary of prescribed conditions</li><li><code>distributed_loads</code>: dictionary of distributed loads</li><li><code>point_masses</code>: dictionary of point masses </li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces/moments</li><li><code>irow_point</code>: row index of first equilibrium equation for each point</li><li><code>irow_elem</code>: row index of first equation for just this beam element</li><li><code>irow_elem1</code>: row index of first equation for the left side of each beam</li><li><code>irow_elem2</code>: row index of first equation for the right side of each beam</li><li><code>icol_point</code>: column index of first state variable for each point</li><li><code>icol_elem</code>: column index of first state variable for each beam element</li><li><code>x0</code>: body frame origin</li><li><code>v0</code>: body frame linear velocity</li><li><code>ω0</code>: body frame angular velocity</li><li><code>a0</code>: body frame linear acceleration</li><li><code>α0</code>: body frame angular acceleration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L1255-L1283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_condition_system_jacobian!" href="#GXBeam.initial_condition_system_jacobian!"><code>GXBeam.initial_condition_system_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_condition_system_jacobian!(jacob, x, assembly,
    prescribed_conditions, distributed_loads, point_masses, gvec, force_scaling,
    irow_point, irow_elem, irow_elem1, irow_elem2, icol_point, icol_elem,
    x0, v0, ω0, a0, α0, u, θ, udot, θdot)</code></pre><p>Populate the system jacobian matrix <code>jacob</code> for an initial conditions analysis.</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: system jacobian matrix</li><li><code>x</code>: current states of the system</li><li><code>assembly</code>: assembly of nonlinear beam elements</li><li><code>prescribed_conditions</code>: dictionary of prescribed conditions</li><li><code>distributed_loads</code>: dictionary of distributed loads</li><li><code>point_masses</code>: dictionary of point masses </li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces/moments</li><li><code>irow_point</code>: row index of first equilibrium equation for each point</li><li><code>irow_elem</code>: row index of first equation for just this beam element</li><li><code>irow_elem1</code>: row index of first equation for the left side of each beam</li><li><code>irow_elem2</code>: row index of first equation for the right side of each beam</li><li><code>icol_point</code>: column index of first state variable for each point</li><li><code>icol_elem</code>: column index of first state variable for each beam element</li><li><code>x0</code>: body frame origin</li><li><code>v0</code>: body frame linear velocity</li><li><code>ω0</code>: body frame angular velocity</li><li><code>a0</code>: body frame linear acceleration</li><li><code>α0</code>: body frame angular acceleration</li><li><code>u</code>: initial linear deflections for each beam element</li><li><code>θ</code>: initial angular deflections for each beam element</li><li><code>udot</code>: initial linear deflection rates for each beam element</li><li><code>θdot</code>: initial angular deflection rates for each beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L1327-L1359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.newmark_system_jacobian!" href="#GXBeam.newmark_system_jacobian!"><code>GXBeam.newmark_system_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newmark_system_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads, point_masses, gvec,
    force_scaling, irow_point, irow_elem, irow_elem1, irow_elem2,
    icol_point, icol_elem, x0, v0, ω0, a0, α0, udot_init, θdot_init, Vdot_init,
    Ωdot_init, dt)</code></pre><p>Populate the system jacobian matrix <code>jacob</code> for a Newmark scheme time-marching analysis.</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: system jacobian matrix</li><li><code>x</code>: current states of the system</li><li><code>assembly</code>: assembly of nonlinear beam elements</li><li><code>prescribed_conditions</code>: dictionary of prescribed conditions</li><li><code>distributed_loads</code>: dictionary of distributed loads</li><li><code>point_masses</code>: dictionary of point masses </li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces/moments</li><li><code>irow_point</code>: row index of first equilibrium equation for each point</li><li><code>irow_elem</code>: row index of first equation for just this beam element</li><li><code>irow_elem1</code>: row index of first equation for the left side of each beam</li><li><code>irow_elem2</code>: row index of first equation for the right side of each beam</li><li><code>icol_point</code>: column index of first state variable for each point</li><li><code>icol_elem</code>: column index of first state variable for each beam element</li><li><code>x0</code>: body frame origin</li><li><code>v0</code>: body frame linear velocity</li><li><code>ω0</code>: body frame angular velocity</li><li><code>a0</code>: body frame linear acceleration</li><li><code>α0</code>: body frame angular acceleration</li><li><code>udot_init</code>: <code>2/dt*u + udot</code> for each beam element from the previous time step</li><li><code>θdot_init</code>: <code>2/dt*θ + θdot</code> for each beam element from the previous time step</li><li><code>Vdot_init</code>: <code>2/dt*V + Vdot</code> for each beam element from the previous time step</li><li><code>Ωdot_init</code>: <code>2/dt*Ω + Ωdot</code> for each beam element from the previous time step</li><li><code>dt</code>: time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L1404-L1437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_system_jacobian!" href="#GXBeam.dynamic_system_jacobian!"><code>GXBeam.dynamic_system_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_system_jacobian!(jacob, dx, x, assembly,
    prescribed_conditions, distributed_loads, point_masses, gvec, force_scaling,
    irow_point, irow_elem, irow_elem1, irow_elem2, icol_point, icol_elem,
    x0, v0, ω0, a0, α0)</code></pre><p>Populate the jacobian matrix <code>jacob</code> for a general dynamic analysis.</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: system jacobian matrix</li><li><code>dx</code>: current state rates of the system</li><li><code>x</code>: current states of the system</li><li><code>assembly</code>: assembly of nonlinear beam elements</li><li><code>prescribed_conditions</code>: dictionary of prescribed conditions</li><li><code>distributed_loads</code>: dictionary of distributed loads</li><li><code>point_masses</code>: dictionary of point masses </li><li><code>gvec</code>: gravity vector</li><li><code>force_scaling</code>: scaling parameter for forces/moments</li><li><code>irow_point</code>: row index of first equilibrium equation for each point</li><li><code>irow_elem</code>: row index of first equation for just this beam element</li><li><code>irow_elem1</code>: row index of first equation for the left side of each beam</li><li><code>irow_elem2</code>: row index of first equation for the right side of each beam</li><li><code>icol_point</code>: column index of first state variable for each point</li><li><code>icol_elem</code>: column index of first state variable for each beam element</li><li><code>x0</code>: body frame origin</li><li><code>v0</code>: body frame linear velocity</li><li><code>ω0</code>: body frame angular velocity</li><li><code>a0</code>: body frame linear acceleration</li><li><code>α0</code>: body frame angular acceleration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L1486-L1515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_sparsity" href="#GXBeam.get_sparsity"><code>GXBeam.get_sparsity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_sparsity(system, assembly)</code></pre><p>Return a matrix indicating the sparsity structure of the jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L714-L718">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.system_indices" href="#GXBeam.system_indices"><code>GXBeam.system_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">system_indices(start, stop, static; kwargs...)</code></pre><p>Return indices for accessing the equations and state variables associated with each point and beam element in a system given its connectivity.</p><p><strong>Arguments:</strong></p><ul><li><code>start</code>: Vector containing the point indices where each beam element starts</li><li><code>stop</code>: Vector containing the point indices where each beam element stops</li><li><code>static</code>: Flag indicating whether the analysis is static (rather than dynamic).  Defaults to <code>false</code>.</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>prescribed_points</code>: Point indices corresponding to the points whose equations  and state variables should be included in the system of equations.  By default,  all point indices are included in the system of equations.</li></ul><p><strong>Return Arguments:</strong></p><ul><li><code>N</code>: total number of equations and unknowns in the system</li><li><code>irow_point</code>: Row index of the first equation corresponding to each point</li><li><code>irow_elem</code>: Row index of the first equation corresponding to each beam element</li><li><code>irow_elem1</code>: Row index of the first equation corresponding to the start of      each beam element</li><li><code>irow_elem2</code>: Row index of the first equation corresponding to the end of      each beam element</li><li><code>icol_point</code>: Column index of the first state variable corresponding to each      point</li><li><code>icol_elem</code>: Column index of the first state variable corresponding to each      beam element</li></ul><p>Negative indices indicate that the equations and/or state variables associated with the point/beam element have been omitted from the system of equations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L132-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.system_mass_matrix!" href="#GXBeam.system_mass_matrix!"><code>GXBeam.system_mass_matrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">system_mass_matrix!(jacob, x, assembly, point_masses, force_scaling,
    irow_point, irow_elem, irow_elem1, irow_elem2, icol_point, icol_elem)</code></pre><p>Populate the system mass matrix for a general dynamic analysis</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: jacobian of the residuals with respect to the state rates</li><li><code>x</code>: current states of the system</li><li><code>assembly</code>: assembly of nonlinear beam elements</li><li><code>point_masses</code>: dictionary of point masses </li><li><code>force_scaling</code>: scaling parameter for forces/moments</li><li><code>irow_point</code>: row index of the first equilibrium equation for each point</li><li><code>irow_elem</code>: row index of the first linear/angular velocity residual for each element</li><li><code>irow_elem1</code>: row index of the first equation for the left side of each beam</li><li><code>irow_elem2</code>: row index of the first equation for the right side of each beam</li><li><code>icol_point</code>: column index of the first state variable for each point</li><li><code>icol_elem</code>: column index of the first state variable for each beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L1569-L1587">source</a></section><section><div><pre><code class="nohighlight hljs">system_mass_matrix!(jacob, gamma, x, dx, assembly, point_masses, force_scaling,
    irow_point, irow_elem, irow_elem1, irow_elem2, icol_point, icol_elem)</code></pre><p>Add the system mass matrix to <code>jacob</code>, scaled by the scaling parameter <code>gamma</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/76e5f2804c7684c2c3e5cd38f3ed33aeff98b510/src/system.jl#L1618-L1623">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#GXBeam.Assembly-Tuple{Any, Any, Any}"><code>GXBeam.Assembly</code></a></li><li><a href="#GXBeam.Assembly"><code>GXBeam.Assembly</code></a></li><li><a href="#GXBeam.AssemblyState"><code>GXBeam.AssemblyState</code></a></li><li><a href="#GXBeam.AssemblyState-Tuple{Any, Any}"><code>GXBeam.AssemblyState</code></a></li><li><a href="#GXBeam.DistributedLoads-Tuple{Any, Any}"><code>GXBeam.DistributedLoads</code></a></li><li><a href="#GXBeam.DistributedLoads"><code>GXBeam.DistributedLoads</code></a></li><li><a href="#GXBeam.ElementState"><code>GXBeam.ElementState</code></a></li><li><a href="#GXBeam.PointMass-Tuple{Any, Any, Any}"><code>GXBeam.PointMass</code></a></li><li><a href="#GXBeam.PointMass"><code>GXBeam.PointMass</code></a></li><li><a href="#GXBeam.PointState"><code>GXBeam.PointState</code></a></li><li><a href="#GXBeam.PrescribedConditions"><code>GXBeam.PrescribedConditions</code></a></li><li><a href="#GXBeam.PrescribedConditions-Tuple{}"><code>GXBeam.PrescribedConditions</code></a></li><li><a href="#GXBeam.System"><code>GXBeam.System</code></a></li><li><a href="#GXBeam.System-Tuple{Any, Any}"><code>GXBeam.System</code></a></li><li><a href="../diffeq/#SciMLBase.DAEFunction-Tuple{System, Any}"><code>SciMLBase.DAEFunction</code></a></li><li><a href="../diffeq/#SciMLBase.DAEProblem-Tuple{System, Any, Any}"><code>SciMLBase.DAEProblem</code></a></li><li><a href="../diffeq/#SciMLBase.ODEFunction-Tuple{System, Any}"><code>SciMLBase.ODEFunction</code></a></li><li><a href="../diffeq/#SciMLBase.ODEProblem-Tuple{System, Any, Any}"><code>SciMLBase.ODEProblem</code></a></li><li><a href="#GXBeam.acceleration_loads"><code>GXBeam.acceleration_loads</code></a></li><li><a href="#GXBeam.combine_loads"><code>GXBeam.combine_loads</code></a></li><li><a href="#GXBeam.combine_masses"><code>GXBeam.combine_masses</code></a></li><li><a href="#GXBeam.correlate_eigenmodes"><code>GXBeam.correlate_eigenmodes</code></a></li><li><a href="#GXBeam.cross_section_velocities"><code>GXBeam.cross_section_velocities</code></a></li><li><a href="#GXBeam.cross_section_velocities!"><code>GXBeam.cross_section_velocities!</code></a></li><li><a href="#GXBeam.curve_coordinates"><code>GXBeam.curve_coordinates</code></a></li><li><a href="#GXBeam.curve_length"><code>GXBeam.curve_length</code></a></li><li><a href="#GXBeam.curve_triad"><code>GXBeam.curve_triad</code></a></li><li><a href="#GXBeam.deform_cross_section"><code>GXBeam.deform_cross_section</code></a></li><li><a href="#GXBeam.deform_cross_section!"><code>GXBeam.deform_cross_section!</code></a></li><li><a href="#GXBeam.discretize_beam"><code>GXBeam.discretize_beam</code></a></li><li><a href="#GXBeam.dynamic_element_equations"><code>GXBeam.dynamic_element_equations</code></a></li><li><a href="#GXBeam.dynamic_element_jacobian!"><code>GXBeam.dynamic_element_jacobian!</code></a></li><li><a href="#GXBeam.dynamic_element_jacobian_equations"><code>GXBeam.dynamic_element_jacobian_equations</code></a></li><li><a href="#GXBeam.dynamic_element_residual!"><code>GXBeam.dynamic_element_residual!</code></a></li><li><a href="#GXBeam.dynamic_element_state_variables"><code>GXBeam.dynamic_element_state_variables</code></a></li><li><a href="#GXBeam.dynamic_insert_element_jacobian!"><code>GXBeam.dynamic_insert_element_jacobian!</code></a></li><li><a href="#GXBeam.dynamic_insert_element_residual!"><code>GXBeam.dynamic_insert_element_residual!</code></a></li><li><a href="#GXBeam.dynamic_system_jacobian!"><code>GXBeam.dynamic_system_jacobian!</code></a></li><li><a href="#GXBeam.dynamic_system_residual!"><code>GXBeam.dynamic_system_residual!</code></a></li><li><a href="#GXBeam.eigenvalue_analysis"><code>GXBeam.eigenvalue_analysis</code></a></li><li><a href="#GXBeam.eigenvalue_analysis!"><code>GXBeam.eigenvalue_analysis!</code></a></li><li><a href="#GXBeam.element_angular_momentum"><code>GXBeam.element_angular_momentum</code></a></li><li><a href="#GXBeam.element_curvature"><code>GXBeam.element_curvature</code></a></li><li><a href="#GXBeam.element_linear_momentum"><code>GXBeam.element_linear_momentum</code></a></li><li><a href="#GXBeam.element_mass_matrix!"><code>GXBeam.element_mass_matrix!</code></a></li><li><a href="#GXBeam.element_mass_matrix_equations"><code>GXBeam.element_mass_matrix_equations</code></a></li><li><a href="#GXBeam.element_strain"><code>GXBeam.element_strain</code></a></li><li><a href="#GXBeam.extract_element_state"><code>GXBeam.extract_element_state</code></a></li><li><a href="#GXBeam.extract_element_states"><code>GXBeam.extract_element_states</code></a></li><li><a href="#GXBeam.extract_element_states!"><code>GXBeam.extract_element_states!</code></a></li><li><a href="#GXBeam.extract_point_state"><code>GXBeam.extract_point_state</code></a></li><li><a href="#GXBeam.extract_point_states"><code>GXBeam.extract_point_states</code></a></li><li><a href="#GXBeam.extract_point_states!"><code>GXBeam.extract_point_states!</code></a></li><li><a href="#GXBeam.gauss_quadrature"><code>GXBeam.gauss_quadrature</code></a></li><li><a href="#GXBeam.get_C"><code>GXBeam.get_C</code></a></li><li><a href="#GXBeam.get_C_t"><code>GXBeam.get_C_t</code></a></li><li><a href="#GXBeam.get_C_t_θ"><code>GXBeam.get_C_t_θ</code></a></li><li><a href="#GXBeam.get_C_t_θdot"><code>GXBeam.get_C_t_θdot</code></a></li><li><a href="#GXBeam.get_C_θ"><code>GXBeam.get_C_θ</code></a></li><li><a href="#GXBeam.get_Q"><code>GXBeam.get_Q</code></a></li><li><a href="#GXBeam.get_Q_θ"><code>GXBeam.get_Q_θ</code></a></li><li><a href="#GXBeam.get_Qinv"><code>GXBeam.get_Qinv</code></a></li><li><a href="#GXBeam.get_Qinv_θ"><code>GXBeam.get_Qinv_θ</code></a></li><li><a href="#GXBeam.get_sparsity"><code>GXBeam.get_sparsity</code></a></li><li><a href="#GXBeam.initial_condition_analysis"><code>GXBeam.initial_condition_analysis</code></a></li><li><a href="#GXBeam.initial_condition_analysis!"><code>GXBeam.initial_condition_analysis!</code></a></li><li><a href="#GXBeam.initial_condition_element_jacobian!"><code>GXBeam.initial_condition_element_jacobian!</code></a></li><li><a href="#GXBeam.initial_condition_element_jacobian_equations"><code>GXBeam.initial_condition_element_jacobian_equations</code></a></li><li><a href="#GXBeam.initial_condition_element_residual!"><code>GXBeam.initial_condition_element_residual!</code></a></li><li><a href="#GXBeam.initial_condition_insert_element_jacobian!"><code>GXBeam.initial_condition_insert_element_jacobian!</code></a></li><li><a href="#GXBeam.initial_condition_system_jacobian!"><code>GXBeam.initial_condition_system_jacobian!</code></a></li><li><a href="#GXBeam.initial_condition_system_residual!"><code>GXBeam.initial_condition_system_residual!</code></a></li><li><a href="#GXBeam.insert_element_mass_matrix!"><code>GXBeam.insert_element_mass_matrix!</code></a></li><li><a href="#GXBeam.insert_point_jacobian!"><code>GXBeam.insert_point_jacobian!</code></a></li><li><a href="#GXBeam.insert_point_residual!"><code>GXBeam.insert_point_residual!</code></a></li><li><a href="#GXBeam.left_eigenvectors"><code>GXBeam.left_eigenvectors</code></a></li><li><a href="#GXBeam.mul3"><code>GXBeam.mul3</code></a></li><li><a href="#GXBeam.newmark_element_jacobian!"><code>GXBeam.newmark_element_jacobian!</code></a></li><li><a href="#GXBeam.newmark_element_jacobian_equations"><code>GXBeam.newmark_element_jacobian_equations</code></a></li><li><a href="#GXBeam.newmark_element_residual!"><code>GXBeam.newmark_element_residual!</code></a></li><li><a href="#GXBeam.newmark_system_jacobian!"><code>GXBeam.newmark_system_jacobian!</code></a></li><li><a href="#GXBeam.newmark_system_residual!"><code>GXBeam.newmark_system_residual!</code></a></li><li><a href="#GXBeam.point_follower_jacobians"><code>GXBeam.point_follower_jacobians</code></a></li><li><a href="#GXBeam.point_jacobian!"><code>GXBeam.point_jacobian!</code></a></li><li><a href="#GXBeam.point_residual!"><code>GXBeam.point_residual!</code></a></li><li><a href="#GXBeam.point_variables"><code>GXBeam.point_variables</code></a></li><li><a href="#GXBeam.reset_state!"><code>GXBeam.reset_state!</code></a></li><li><a href="#GXBeam.rotate"><code>GXBeam.rotate</code></a></li><li><a href="#GXBeam.rotate!"><code>GXBeam.rotate!</code></a></li><li><a href="#GXBeam.rotation_parameter_scaling"><code>GXBeam.rotation_parameter_scaling</code></a></li><li><a href="#GXBeam.set_element_angular_velocity!"><code>GXBeam.set_element_angular_velocity!</code></a></li><li><a href="#GXBeam.set_element_deflection!"><code>GXBeam.set_element_deflection!</code></a></li><li><a href="#GXBeam.set_element_forces!"><code>GXBeam.set_element_forces!</code></a></li><li><a href="#GXBeam.set_element_linear_velocity!"><code>GXBeam.set_element_linear_velocity!</code></a></li><li><a href="#GXBeam.set_element_moments!"><code>GXBeam.set_element_moments!</code></a></li><li><a href="#GXBeam.set_element_rotation!"><code>GXBeam.set_element_rotation!</code></a></li><li><a href="#GXBeam.set_point_deflections!"><code>GXBeam.set_point_deflections!</code></a></li><li><a href="#GXBeam.set_point_forces!"><code>GXBeam.set_point_forces!</code></a></li><li><a href="#GXBeam.set_point_moments!"><code>GXBeam.set_point_moments!</code></a></li><li><a href="#GXBeam.set_point_rotations!"><code>GXBeam.set_point_rotations!</code></a></li><li><a href="#GXBeam.set_state!"><code>GXBeam.set_state!</code></a></li><li><a href="#GXBeam.static_analysis"><code>GXBeam.static_analysis</code></a></li><li><a href="#GXBeam.static_analysis!"><code>GXBeam.static_analysis!</code></a></li><li><a href="#GXBeam.static_element_equations"><code>GXBeam.static_element_equations</code></a></li><li><a href="#GXBeam.static_element_jacobian!"><code>GXBeam.static_element_jacobian!</code></a></li><li><a href="#GXBeam.static_element_jacobian_equations"><code>GXBeam.static_element_jacobian_equations</code></a></li><li><a href="#GXBeam.static_element_residual!"><code>GXBeam.static_element_residual!</code></a></li><li><a href="#GXBeam.static_element_state_variables"><code>GXBeam.static_element_state_variables</code></a></li><li><a href="#GXBeam.static_insert_element_jacobian!"><code>GXBeam.static_insert_element_jacobian!</code></a></li><li><a href="#GXBeam.static_insert_element_residual!"><code>GXBeam.static_insert_element_residual!</code></a></li><li><a href="#GXBeam.static_system_jacobian!"><code>GXBeam.static_system_jacobian!</code></a></li><li><a href="#GXBeam.static_system_residual!"><code>GXBeam.static_system_residual!</code></a></li><li><a href="#GXBeam.steady_state_analysis"><code>GXBeam.steady_state_analysis</code></a></li><li><a href="#GXBeam.steady_state_analysis!"><code>GXBeam.steady_state_analysis!</code></a></li><li><a href="#GXBeam.steady_state_element_equations"><code>GXBeam.steady_state_element_equations</code></a></li><li><a href="#GXBeam.steady_state_element_jacobian!"><code>GXBeam.steady_state_element_jacobian!</code></a></li><li><a href="#GXBeam.steady_state_element_jacobian_equations"><code>GXBeam.steady_state_element_jacobian_equations</code></a></li><li><a href="#GXBeam.steady_state_element_residual!"><code>GXBeam.steady_state_element_residual!</code></a></li><li><a href="#GXBeam.steady_state_system_jacobian!"><code>GXBeam.steady_state_system_jacobian!</code></a></li><li><a href="#GXBeam.steady_state_system_residual!"><code>GXBeam.steady_state_system_residual!</code></a></li><li><a href="#GXBeam.system_indices"><code>GXBeam.system_indices</code></a></li><li><a href="#GXBeam.system_mass_matrix!"><code>GXBeam.system_mass_matrix!</code></a></li><li><a href="#GXBeam.system_state"><code>GXBeam.system_state</code></a></li><li><a href="#GXBeam.tilde"><code>GXBeam.tilde</code></a></li><li><a href="#GXBeam.time_domain_analysis"><code>GXBeam.time_domain_analysis</code></a></li><li><a href="#GXBeam.time_domain_analysis!"><code>GXBeam.time_domain_analysis!</code></a></li><li><a href="#GXBeam.transform_properties"><code>GXBeam.transform_properties</code></a></li><li><a href="#GXBeam.translate"><code>GXBeam.translate</code></a></li><li><a href="#GXBeam.translate!"><code>GXBeam.translate!</code></a></li><li><a href="#GXBeam.wiener_milenkovic"><code>GXBeam.wiener_milenkovic</code></a></li><li><a href="#GXBeam.write_vtk"><code>GXBeam.write_vtk</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../diffeq/">« Using GXBeam with DifferentialEquations.jl</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 15 November 2021 21:30">Monday 15 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
