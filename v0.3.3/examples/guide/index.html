<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · GXBeam.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GXBeam.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li class="is-active"><a class="tocitem" href>Getting Started</a><ul class="internal"><li><a class="tocitem" href="#Creating-an-Assembly"><span>Creating an Assembly</span></a></li><li><a class="tocitem" href="#Point-Masses"><span>Point Masses</span></a></li><li><a class="tocitem" href="#Defining-Distributed-Loads"><span>Defining Distributed Loads</span></a></li><li><a class="tocitem" href="#Defining-Prescribed-Conditions"><span>Defining Prescribed Conditions</span></a></li><li><a class="tocitem" href="#Pre-Allocating-Memory-for-an-Analysis"><span>Pre-Allocating Memory for an Analysis</span></a></li><li><a class="tocitem" href="#Eliminating-Unnecessary-State-Variables"><span>Eliminating Unnecessary State Variables</span></a></li><li><a class="tocitem" href="#Performing-a-Steady-State-Analysis"><span>Performing a Steady State Analysis</span></a></li><li><a class="tocitem" href="#Post-Processing-Results"><span>Post Processing Results</span></a></li><li><a class="tocitem" href="#Other-Capabilities"><span>Other Capabilities</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../cantilever/">Cantilever with a Uniform Load</a></li><li><a class="tocitem" href="../overdetermined/">Overdetermined Beam</a></li><li><a class="tocitem" href="../tipforce/">Cantilever with a Tip Force</a></li><li><a class="tocitem" href="../tipmoment/">Cantilever with a Tip Moment</a></li><li><a class="tocitem" href="../curved/">Bending of an Initially Curved Beam</a></li><li><a class="tocitem" href="../rotating/">Rotating Beam with a Swept Tip</a></li><li><a class="tocitem" href="../wind-turbine-blade/">Time-Domain Simulation of a Wind Turbine Blade</a></li><li><a class="tocitem" href="../static-joined-wing/">Static Analysis of a Joined-Wing</a></li><li><a class="tocitem" href="../dynamic-joined-wing/">Time-Domain Simulation of a Joined-Wing</a></li><li><a class="tocitem" href="../vertical-axis-wind-turbine/">Sandia 34-Meter Vertical Axis Wind Turbine</a></li></ul></li><li><a class="tocitem" href="../diffeq/">Using GXBeam with DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../reference/reference/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting Started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/literate/guide.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="guide"><a class="docs-heading-anchor" href="#guide">Getting Started</a><a id="guide-1"></a><a class="docs-heading-anchor-permalink" href="#guide" title="Permalink"></a></h1><p>In this guide we introduce you to the basic functionality of this package in a step by step manner.  This is a good starting point for learning about how to use this package.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>This guide is also available as a Jupyter notebook: <a href="https://nbviewer.jupyter.org/github/byuflowlab/GXBeam.jl/blob/gh-pages/v0.3.3/examples/guide.ipynb"><code>guide.ipynb</code></a>.</p></div></div><p>If you haven&#39;t yet, now would be a good time to install GXBeam.  It can be installed from the Julia REPL by typing <code>]</code> (to enter the package manager) and then running <code>add GXBeam</code>.</p><p>Now, that the package is installed we need to load it so that we can use it.  It&#39;s also often helpful to load the LinearAlgebra package.</p><pre><code class="language-julia hljs">using GXBeam, LinearAlgebra</code></pre><p>The geometry we will be working with is a rotating beam with a swept tip as pictured.</p><p><img src="../../assets/rotating-drawing.svg" alt/></p><p>This geometry has a fixed boundary condition on the left side of the beam and rotates around a point 2.5 inches to the left of the beam.  We will investigating the steady behavior of this system for a variety of RPM settings at a constant sweep of 45°.</p><h2 id="Creating-an-Assembly"><a class="docs-heading-anchor" href="#Creating-an-Assembly">Creating an Assembly</a><a id="Creating-an-Assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-an-Assembly" title="Permalink"></a></h2><p>The first step for any analysis is to create an object of type <a href="../../reference/reference/#GXBeam.Assembly"><code>Assembly</code></a>.  This object stores the properties of each of the points and beam elements in our model.</p><p>To create an object of type Assembly we need the following:</p><ul><li>An array of points</li><li>The starting point for each beam element</li><li>The ending point for each beam element</li><li>The frame of reference for each beam element, specified as a 3x3 direction cosine matrix</li><li>The stiffness or compliance matrix for each beam element</li><li>The mass or inverse mass matrix for each beam element, for dynamic simulations</li><li>The element length and midpoint, if the element is curved</li></ul><p>We will first focus on the geometry.  We start by defining the straight section of the beam.  This section extends from (2.5, 0, 0) to (34, 0, 0).  The local coordinate frame for this section of the beam is the same as the global coordinate frame.  We will discretize this section into 10 elements.</p><p>To aid with constructing the geometry we can use the <a href="../../reference/reference/#GXBeam.discretize_beam"><code>discretize_beam</code></a> function. We pass in the length, starting point, and number of elements of the beam section to the <a href="../../reference/reference/#GXBeam.discretize_beam"><code>discretize_beam</code></a> function.  The function returns the lengths, endpoints, midpoints, and reference frame of each beam element.</p><pre><code class="language-julia hljs"># straight section of the beam
L_b1 = 31.5 # length of straight section of the beam in inches
r_b1 = [2.5, 0, 0] # starting point of straight section of the beam
nelem_b1 = 10 # number of elements in the straight section of the beam
lengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1)</code></pre><p>The length of each beam element is equal since we used the number of elements to define the discretization.  Alternatively we can manually specify the discretization of the section. The following is equivalent.</p><pre><code class="language-julia hljs"># normalized element endpoints in the straight section of the beam
disc_b1 = range(0, 1, length=nelem_b1+1)

# discretize straight beam section
lengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, disc_b1)</code></pre><p>We now create the geometry for the swept portion of the wing.  To do so we use the same <a href="../../reference/reference/#GXBeam.discretize_beam"><code>discretize_beam</code></a> function, but use the additional keyword argument <code>frame</code> in order to define the undeformed local beam frame.  The direction cosine matrix which describes the local beam frame is</p><p class="math-container">\[\begin{bmatrix}
\hat{e_{1,x}} &amp; \hat{e_{2,x}} &amp; \hat{e_{3,x}} \\
\hat{e_{1,y}} &amp; \hat{e_{2,y}} &amp; \hat{e_{3,y}} \\
\hat{e_{1,z}} &amp; \hat{e_{2,z}} &amp; \hat{e_{3,z}} \\
\end{bmatrix}\]</p><p>where <span>$\hat{e_1}$</span>, <span>$\hat{e_2}$</span>, and <span>$\hat{e_3}$</span> are unit vectors which define the axes of the local frame of reference in the body frame of reference.  This matrix may be interpreted as a transformation matrix from the undeformed local beam frame to the body frame.</p><pre><code class="language-julia hljs">sweep = 45 * pi/180

# swept section of the beam
L_b2 = 6 # length of swept section of the beam
r_b2 = [34, 0, 0] # starting point of swept section of the beam
nelem_b2 = 5 # number of elements in swept section of the beam
e1 = [cos(sweep), -sin(sweep), 0] # axis 1
e2 = [sin(sweep), cos(sweep), 0] # axis 2
e3 = [0, 0, 1] # axis 3
frame_b2 = hcat(e1, e2, e3) # transformation matrix from local to body frame
lengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2;
    frame = frame_b2)</code></pre><p>We will now manually combine the results of our two calls to <code>discretize_beam</code>.  Since the last endpoint from the straight section is the same as the first endpoint of the swept section we drop one of the endpoints when combining our results.</p><pre><code class="language-julia hljs"># combine elements and points into one array
nelem = nelem_b1 + nelem_b2 # total number of elements
points = vcat(xp_b1, xp_b2[2:end]) # all points in our assembly
start = 1:nelem_b1 + nelem_b2 # starting point of each beam element in our assembly
stop = 2:nelem_b1 + nelem_b2 + 1 # ending point of each beam element in our assembly
lengths = vcat(lengths_b1, lengths_b2) # length of each beam element in our assembly
midpoints = vcat(xm_b1, xm_b2) # midpoint of each beam element in our assembly
Cab = vcat(Cab_b1, Cab_b2) # transformation matrix from local to body frame
                           # for each beam element in our assembly</code></pre><p>Next we need to define the stiffness (or compliance) and mass matrices for each beam element.</p><p>The compliance matrix is defined by the following equation</p><p class="math-container">\[\begin{bmatrix}
\gamma_{11} \\
2\gamma_{12} \\
2\gamma_{13} \\
\kappa_{1} \\
\kappa_{2} \\
\kappa_{3}
\end{bmatrix}
=
\begin{bmatrix}
   S_{11} &amp; S_{12} &amp; S_{13} &amp; S_{14} &amp; S_{15} &amp; S_{16} \\
   S_{12} &amp; S_{22} &amp; S_{23} &amp; S_{24} &amp; S_{25} &amp; S_{26} \\
   S_{13} &amp; S_{23} &amp; S_{33} &amp; S_{34} &amp; S_{35} &amp; S_{36} \\
   S_{14} &amp; S_{24} &amp; S_{43} &amp; S_{44} &amp; S_{45} &amp; S_{46} \\
   S_{15} &amp; S_{25} &amp; S_{35} &amp; S_{45} &amp; S_{55} &amp; S_{56} \\
   S_{16} &amp; S_{26} &amp; S_{36} &amp; S_{46} &amp; S_{56} &amp; S_{66}
\end{bmatrix}
\begin{bmatrix}
   F_{1} \\
   F_{2} \\
   F_{3} \\
   M_{1} \\
   M_{2} \\
   M_{3}
\end{bmatrix}\]</p><p>with the variables defined as follows:</p><ul><li><span>$\gamma_{11}$</span>: beam axial strain</li><li><span>$2\gamma_{12}$</span> engineering transverse strain along axis 2</li><li><span>$2\gamma_{13}$</span> engineering transverse strain along axis 3</li><li><span>$\kappa_1$</span>: twist</li><li><span>$\kappa_2$</span>: curvature about axis 2</li><li><span>$\kappa_3$</span>: curvature about axis 3</li><li><span>$F_i$</span>: resultant force about axis i</li><li><span>$M_i$</span>: resultant moment about axis i</li></ul><p>The mass matrix is defined using the following equation</p><p class="math-container">\[\begin{bmatrix}
   P_{1} \\
   P_{2} \\
   P_{3} \\
   H_{1} \\
   H_{2} \\
   H_{3}
\end{bmatrix}
=
\begin{bmatrix}
   \mu &amp; 0 &amp; 0 &amp; 0 &amp; \mu x_{m3} &amp; -\mu x_{m2} \\
   0 &amp; \mu &amp; 0 &amp; -\mu x_{m3} &amp; 0 &amp; 0 \\
   0 &amp; 0 &amp; \mu &amp; \mu x_{m2} &amp; 0 &amp; 0 \\
   0 &amp; -\mu x_{m3} &amp; \mu x_{m2} &amp; i_{22} + i_{33} &amp; 0 &amp; 0 \\
   \mu x_{m3}  &amp; 0 &amp; 0 &amp; 0 &amp; i_{22} &amp; -i_{23} \\
   -\mu x_{m2} &amp; 0 &amp; 0 &amp; 0 &amp; -i_{23} &amp; i_{33}
\end{bmatrix}
\begin{bmatrix}
   V_{1} \\
   V_{2} \\
   V_{3} \\
   \Omega_{1} \\
   \Omega_{2} \\
   \Omega_{3}
\end{bmatrix}\]</p><p>with the variables defined as follows:</p><ul><li><span>$P$</span>: linear momentum per unit length</li><li><span>$H$</span>: angular momentum per unit length</li><li><span>$V$</span>: linear velocity</li><li><span>$\Omega$</span>: angular velocity</li><li><span>$\mu$</span>: mass per unit length</li><li><span>$(x_{m2}, x_{m3})$</span>: mass center location</li><li><span>$i_{22}$</span>: mass moment of inertia about axis 2</li><li><span>$i_{33}$</span>: mass moment of inertia about axis 3</li><li><span>$i_{23}$</span>: product of inertia</li></ul><p>We assume that our beam has a constant cross section with the following properties:</p><ul><li>1 inch width</li><li>0.063 inch height</li><li>1.06 x 10^7 lb/in^2 elastic modulus</li><li>0.325 Poisson&#39;s ratio</li><li>2.51 x 10^-4 lb sec^2/in^4 density</li></ul><p>We also assume the following shear and torsion correction factors:</p><ul><li><span>$k_y = 1.2000001839588001$</span></li><li><span>$k_z = 14.625127919304001$</span></li><li><span>$k_t = 65.85255016982444$</span></li></ul><pre><code class="language-julia hljs"># cross section
w = 1 # inch
h = 0.063 # inch

# material properties
E = 1.06e7 # lb/in^2
ν = 0.325
ρ = 2.51e-4 # lb sec^2/in^4

# shear and torsion correction factors
ky = 1.2000001839588001
kz = 14.625127919304001
kt = 65.85255016982444

A = h*w
Iyy = w*h^3/12
Izz = w^3*h/12
J = Iyy + Izz

# apply corrections
Ay = A/ky
Az = A/kz
Jx = J/kt

G = E/(2*(1+ν))

compliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*Jx), 1/(E*Iyy),
    1/(E*Izz)]), nelem)

mass = fill(Diagonal([ρ*A, ρ*A, ρ*A, ρ*J, ρ*Iyy, ρ*Izz]), nelem)</code></pre><p>Our case is simple enough that we can analytically calculate most values for the compliance and mass matrices, but this is not generally the case.  For more complex geometries/structures it may be necessary to use a cross-sectional property solver such as <a href="https://www.altair.com/vabs/#:~:text=VABS%20by%20AnalySwift%2C%20is%20a%20general-purpose%20cross-sectional%20analysis,3D%20stresses%20and%20strains%20of%20slender%20composite%20structures.">VABS</a>, <a href="https://becas.dtu.dk/">BECAS</a>, <a href="https://energy.sandia.gov/programs/renewable-energy/wind-power/rotor-innovation/numerical-manufacturing-and-design-tool-numad/">NuMAD/BPE</a>, or <a href="https://www.nrel.gov/wind/nwtc/precomp.html">PreComp</a>.</p><p>Also note that any row/column of the stiffness and/or compliance matrix which is zero will be interpreted as infinitely stiff in that degree of freedom.  This corresponds to a row/column of zeros in the compliance matrix.</p><p>We are now ready to put together our assembly.</p><pre><code class="language-julia hljs">assembly = Assembly(points, start, stop;
   compliance = compliance,
   mass = mass,
   frames = Cab,
   lengths = lengths,
   midpoints = midpoints)</code></pre><p>At this point this is probably a good time to check that the geometry of our assembly is correct.  We can do this by visualizing the geometry in ParaView.  We can use the <a href="../../reference/reference/#GXBeam.write_vtk"><code>write_vtk</code></a> function to do this.  Note that in order to visualize the generated file yourself you will need to install ParaView separately.</p><pre><code class="language-julia hljs">write_vtk(&quot;rotating-geometry&quot;, assembly)</code></pre><p><img src="../../assets/rotating-geometry.png" alt/></p><h2 id="Point-Masses"><a class="docs-heading-anchor" href="#Point-Masses">Point Masses</a><a id="Point-Masses-1"></a><a class="docs-heading-anchor-permalink" href="#Point-Masses" title="Permalink"></a></h2><p>We won&#39;t be applying point masses to our model, but we will demonstrate how to do so.</p><p>Point masses are defined by using the constructor <a href="../../reference/reference/#GXBeam.PointMass"><code>PointMass</code></a>.  Point masses may be attached to the center of any beam element.  By using zero length beam elements, point masses may also be effectively attached to points.  One instance of <a href="../../reference/reference/#GXBeam.PointMass"><code>PointMass</code></a> must be created for every beam element to which point masses are attached.  These instances are then stored in a dictionary with keys corresponding to each beam element index.</p><p>Each <a href="../../reference/reference/#GXBeam.PointMass"><code>PointMass</code></a> contains a 6x6 mass matrix which describes the relationship between the linear/angular velocity of the beam element and the linear/angular momentum of the point mass.  For a single point mass, this matrix is defined as</p><p class="math-container">\[\begin{bmatrix}
   P_{x} \\
   P_{y} \\
   P_{z} \\
   H_{x} \\
   H_{y} \\
   H_{z}
\end{bmatrix}
=
\begin{bmatrix}
   m &amp; 0 &amp; 0 &amp; 0 &amp; m p_{z} &amp; -m p_{y} \\
   0 &amp; m &amp; 0 &amp; -m p_{z} &amp; 0 &amp; m p_{x} \\
   0 &amp; 0 &amp; m &amp; m p_{y} &amp; -m p_{x} &amp; 0 \\
   0 &amp; -m p_{z} &amp; m p_{y} &amp; I_{xx}^* &amp; -I_{xy}^* &amp; -I_{xz}^* \\
   m p_{z}  &amp; 0 &amp; -m p_{x} &amp; -I_{xy}^* &amp; I_{yy}^* &amp; -I_{yz}^* \\
   -m p_{y} &amp; m p_{x} &amp; 0 &amp; -I_{xz}^* &amp; -I_{yz}^* &amp; I_{zz}^*
\end{bmatrix}
\begin{bmatrix}
   V_{x} \\
   V_{y} \\
   V_{z} \\
   \Omega_{x} \\
   \Omega_{y} \\
   \Omega_{z}
\end{bmatrix}\]</p><p>where <span>$m$</span> is the mass of the point mass, <span>$p$</span> is the position of the point mass relative to the center of the beam element to which it is attached, and <span>$I^*$</span> is the inertia matrix corresponding to the point mass, defined relative to the center of the beam element.  Multiple point masses may be modeled by adding their respective mass matrices together.</p><p>Objects of type <a href="../../reference/reference/#GXBeam.PointMass"><code>PointMass</code></a> may be constructed by providing the fully populated mass matrix as described above or by providing the mass, offset, and inertia matrix of the point mass, with the later being the inertia matrix of the point mass about its center of gravity rather than the beam center.  To demonstrate, the following code places a 10 kg tip mass at the end of the beam, which is rigidly attached to the center of the final beam element</p><pre><code class="language-julia hljs">m = 10 # mass
p = xp_b2[end] - xm_b2[end] # relative location
J = zeros(3,3) # inertia matrix (about the point mass center of gravity)

# create dictionary of point masses
point_masses = Dict(
    nelem =&gt; PointMass(m, p, J)
    )</code></pre><h2 id="Defining-Distributed-Loads"><a class="docs-heading-anchor" href="#Defining-Distributed-Loads">Defining Distributed Loads</a><a id="Defining-Distributed-Loads-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Distributed-Loads" title="Permalink"></a></h2><p>We won&#39;t be applying distributed loads to our model, but we will demonstrate how to do so.</p><p>Distributed loads are defined by using the constructor <a href="../../reference/reference/#GXBeam.DistributedLoads"><code>DistributedLoads</code></a>.  One instance of <a href="../../reference/reference/#GXBeam.DistributedLoads"><code>DistributedLoads</code></a> must be created for every beam element on which the distributed load is applied.  These instances of <a href="../../reference/reference/#GXBeam.DistributedLoads"><code>DistributedLoads</code></a> are then stored in a dictionary with keys corresponding to each beam element index.</p><p>To define a <a href="../../reference/reference/#GXBeam.DistributedLoads"><code>DistributedLoads</code></a> the assembly, element number, and distributed load functions must be passed to <a href="../../reference/reference/#GXBeam.DistributedLoads"><code>DistributedLoads</code></a>.  Possible distributed load functions are:</p><ul><li><code>fx</code>: Distributed x-direction force</li><li><code>fy</code>: Distributed y-direction force</li><li><code>fz</code>: Distributed z-direction force</li><li><code>mx</code>: Distributed x-direction moment</li><li><code>my</code>: Distributed y-direction moment</li><li><code>mz</code>: Distributed z-direction moment</li><li><code>fx_follower</code>: Distributed x-direction follower force</li><li><code>fy_follower</code>: Distributed y-direction follower force</li><li><code>fz_follower</code>: Distributed z-direction follower force</li><li><code>mx_follower</code>: Distributed x-direction follower moment</li><li><code>my_follower</code>: Distributed y-direction follower moment</li><li><code>mz_follower</code>: Distributed z-direction follower moment</li></ul><p>Each of these forces/moments are specified as functions of the arbitrary coordinate <code>s</code> (<span>$f(s)$</span>).  The s-coordinate at the start and end of the beam element can be specified using the keyword arguments <code>s1</code> and <code>s2</code>.</p><p>For example, the following code applies a uniform 10 pound distributed load in the z-direction on all beam elements:</p><pre><code class="language-julia hljs">distributed_loads = Dict()
for ielem in 1:nelem
    distributed_loads[ielem] = DistributedLoads(assembly, ielem; fz = (s) -&gt; 10)
end</code></pre><p>To instead use a follower force (a force that rotates with the structure) we would use the following code:</p><pre><code class="language-julia hljs">distributed_loads = Dict()
for ielem in 1:nelem
    distributed_loads[ielem] = DistributedLoads(assembly, ielem;
        fz_follower = (s) -&gt; 10)
end</code></pre><p>The units are arbitrary, but must be consistent with the units used when constructing the beam assembly.  Also note that both non-follower and follower forces may exist simultaneously.</p><p>It is worth noting that the distributed loads are integrated over each element when they are created using 4-point Gauss-Legendre quadrature.  If more control over the integration is desired one may specify a custom integration method as described in the documentation for <a href="../../reference/reference/#GXBeam.DistributedLoads"><code>DistributedLoads</code></a>.</p><h2 id="Defining-Prescribed-Conditions"><a class="docs-heading-anchor" href="#Defining-Prescribed-Conditions">Defining Prescribed Conditions</a><a id="Defining-Prescribed-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Prescribed-Conditions" title="Permalink"></a></h2><p>Whereas distributed loads are applied to beam elements, prescribed conditions are forces and/or displacement boundary conditions applied to points. One instance of <code>PrescribedConditions</code> must be created for every point on which prescribed conditions are applied.  These instances of <code>PrescribedConditions</code> are then stored in a dictionary with keys corresponding to each point index.</p><p>Possible prescribed conditions include:</p><ul><li><code>ux</code>: Prescribed x-displacement</li><li><code>uy</code>: Prescribed y-displacement</li><li><code>uz</code>: Prescribed z-displacement</li><li><code>theta_x</code>: Prescribed first Wiener-Milenkovic parameter</li><li><code>theta_y</code>: Prescribed second Wiener-Milenkovic parameter</li><li><code>theta_z</code>: Prescribed third Wiener-Milenkovic parameter</li><li><code>Fx</code>: Prescribed x-direction force</li><li><code>Fy</code>: Prescribed y-direction force</li><li><code>Fz</code>: Prescribed z-direction force</li><li><code>Mx</code>: Prescribed x-axis moment</li><li><code>My</code>: Prescribed y-axis moment</li><li><code>Mz</code>: Prescribed z-axis moment</li><li><code>Fx_follower</code>: Prescribed x-direction follower force</li><li><code>Fy_follower</code>: Prescribed y-direction follower force</li><li><code>Fz_follower</code>: Prescribed z-direction follower force</li><li><code>Mx_follower</code>: Prescribed x-direction follower moment</li><li><code>My_follower</code>: Prescribed y-direction follower moment</li><li><code>Mz_follower</code>: Prescribed z-direction follower moment</li></ul><p>One can apply both force and displacement boundary conditions to the same point, but one cannot specify a force and displacement condition at the same point corresponding to the same degree of freedom.</p><p>Here we create a fixed boundary condition on the left side of the beam.</p><pre><code class="language-julia hljs"># create dictionary of prescribed conditions
prescribed_conditions = Dict(
    # root section is fixed
    1 =&gt; PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)
    )</code></pre><p>Note that most problems should have at least one point where deflections and/or rotations are constrained in order to be well-posed.</p><h2 id="Pre-Allocating-Memory-for-an-Analysis"><a class="docs-heading-anchor" href="#Pre-Allocating-Memory-for-an-Analysis">Pre-Allocating Memory for an Analysis</a><a id="Pre-Allocating-Memory-for-an-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-Allocating-Memory-for-an-Analysis" title="Permalink"></a></h2><p>At this point we have everything we need to perform an analysis.  However, since we will be performing multiple analyses using the same assembly we can save computational time be pre-allocating memory for the analysis.  This can be done by constructing an object of type <a href="../../reference/reference/#GXBeam.System"><code>System</code></a>.  The constructor for this object requires that we provide the assembly and a flag indicating whether the system is static.</p><pre><code class="language-julia hljs">system = System(assembly, false)</code></pre><h2 id="Eliminating-Unnecessary-State-Variables"><a class="docs-heading-anchor" href="#Eliminating-Unnecessary-State-Variables">Eliminating Unnecessary State Variables</a><a id="Eliminating-Unnecessary-State-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Eliminating-Unnecessary-State-Variables" title="Permalink"></a></h2><p>The time needed to perform our analysis can be further reduced by removing unnecessary state variables and equations from the system of equations.  This optimization may be enabled by providing the identities of the points with prescribed conditions using the <code>prescribed_points</code> keyword.</p><pre><code class="language-julia hljs">system = System(assembly, false; prescribed_points=[1, nelem+1])</code></pre><h2 id="Performing-a-Steady-State-Analysis"><a class="docs-heading-anchor" href="#Performing-a-Steady-State-Analysis">Performing a Steady State Analysis</a><a id="Performing-a-Steady-State-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Performing-a-Steady-State-Analysis" title="Permalink"></a></h2><p>We&#39;re now ready to perform our steady state analyses.  This can be done by calling <a href="../../reference/reference/#GXBeam.steady_state_analysis"><code>steady_state_analysis</code></a> with the pre-allocated system storage, assembly, angular velocity, and the prescribed point conditions.  We can also perform a linear analysis instead of a nonlinear analysis by using the <code>linear</code> keyword argument.</p><p>After each analysis we&#39;ll also construct an object of type <a href="../../reference/reference/#GXBeam.AssemblyState"><code>AssemblyState</code></a> so that we can save the results of each analysis prior to re-using the pre-allocated memory for the next analysis.</p><pre><code class="language-julia hljs">rpm = 0:25:750

linear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))
for i = 1:length(rpm)

    # global frame rotation
    w0 = [0, 0, rpm[i]*(2*pi)/60]

    # perform linear steady state analysis
    _, converged = steady_state_analysis!(system, assembly,
        angular_velocity = w0,
        prescribed_conditions = prescribed_conditions,
        linear = true)

    linear_states[i] = AssemblyState(system, assembly;
        prescribed_conditions=prescribed_conditions)

end

reset_state!(system)

nonlinear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))
for i = 1:length(rpm)

   # global frame rotation
   w0 = [0, 0, rpm[i]*(2*pi)/60]

    # perform nonlinear steady state analysis
    _, converged = steady_state_analysis!(system, assembly,
        angular_velocity = w0,
        prescribed_conditions = prescribed_conditions)

     nonlinear_states[i] = AssemblyState(system, assembly;
         prescribed_conditions=prescribed_conditions)

end</code></pre><h2 id="Post-Processing-Results"><a class="docs-heading-anchor" href="#Post-Processing-Results">Post Processing Results</a><a id="Post-Processing-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Post-Processing-Results" title="Permalink"></a></h2><p>We can access the fields in each instance of <a href="../../reference/reference/#GXBeam.AssemblyState"><code>AssemblyState</code></a> in order to plot various quantities of interest.  This object stores an array of objects of type <a href="../../reference/reference/#GXBeam.PointState"><code>PointState</code></a> in the field <code>points</code> and an array of objects of type <a href="../../reference/reference/#GXBeam.ElementState"><code>ElementState</code></a> in the field <code>elements</code>.</p><p>The fields of <a href="../../reference/reference/#GXBeam.PointState"><code>PointState</code></a> are the following:</p><ul><li><code>u</code>: point linear displacement (in the global frame)</li><li><code>theta</code>: point angular displacement (in the global frame)</li><li><code>F</code>: externally applied forces on the point (in the global frame)</li><li><code>M</code>: externally applied moments on the point (in the global frame)</li></ul><p>The fields of <a href="../../reference/reference/#GXBeam.ElementState"><code>ElementState</code></a> are the following:</p><ul><li><code>u</code>: element displacement (in the global frame )</li><li><code>theta</code>: angular displacement (in the global frame)</li><li><code>F</code>: resultant forces (in the deformed element coordinate frame)</li><li><code>M</code>: resultant moments (in the deformed element coordinate frame)</li><li><code>V</code>: linear velocity (in the deformed element coordinate frame)</li><li><code>Omega</code>: angular velocity (in the deformed element coordinate frame)</li></ul><p>To demonstrate how these fields can be accessed we will now plot the root moment and tip deflections.</p><pre><code class="language-julia hljs">using Plots
pyplot()</code></pre><pre><code class="language-julia hljs"># root moment
plot(
    xlim = (0, 760),
    xticks = 0:100:750,
    xlabel = &quot;Angular Speed (RPM)&quot;,
    yticks = 0.0:2:12,
    ylabel = &quot;\$M_z\$ at the root (lb-in)&quot;,
    grid = false,
    overwrite_figure=false
    )
Mz_nl = [-nonlinear_states[i].points[1].M[3] for i = 1:length(rpm)]
Mz_l = [-linear_states[i].points[1].M[3] for i = 1:length(rpm)]
plot!(rpm, Mz_nl, label=&quot;Nonlinear&quot;)
plot!(rpm, Mz_l, label=&quot;Linear&quot;)
plot!(show=true)</code></pre><p><img src="../../assets/guide-Mz.svg" alt/></p><pre><code class="language-julia hljs"># x tip deflection
plot(
    xlim = (0, 760),
    xticks = 0:100:750,
    xlabel = &quot;Angular Speed (RPM)&quot;,
    ylim = (-0.002, 0.074),
    yticks = 0.0:0.01:0.07,
    ylabel = &quot;\$u_x\$ at the tip (in)&quot;,
    grid = false,
    overwrite_figure=false
    )
ux_nl = [nonlinear_states[i].points[end].u[1] for i = 1:length(rpm)]
ux_l = [linear_states[i].points[end].u[1] for i = 1:length(rpm)]
plot!(rpm, ux_nl, label=&quot;Nonlinear&quot;)
plot!(rpm, ux_l, label=&quot;Linear&quot;)
plot!(show=true)</code></pre><p><img src="../../assets/guide-ux.svg" alt/></p><pre><code class="language-julia hljs"># y tip deflection
plot(
    xlim = (0, 760),
    xticks = 0:100:750,
    xlabel = &quot;Angular Speed (RPM)&quot;,
    ylim = (-0.01, 0.27),
    yticks = 0.0:0.05:0.25,
    ylabel = &quot;\$u_y\$ at the tip (in)&quot;,
    grid = false,
    overwrite_figure=false
    )
uy_nl = [nonlinear_states[i].points[end].u[2] for i = 1:length(rpm)]
uy_l = [linear_states[i].points[end].u[2] for i = 1:length(rpm)]
plot!(rpm, uy_nl, label=&quot;Nonlinear&quot;)
plot!(rpm, uy_l, label=&quot;Linear&quot;)
plot!(show=true)</code></pre><p><img src="../../assets/guide-uy.svg" alt/></p><pre><code class="language-julia hljs"># rotation of the tip
plot(
    xlim = (0, 760),
    xticks = 0:100:750,
    xlabel = &quot;Angular Speed (RPM)&quot;,
    ylabel = &quot;\$θ_z\$ at the tip&quot;,
    grid = false,
    overwrite_figure=false
    )
theta_z_nl = [4*atan(nonlinear_states[i].points[end].theta[3]/4)
    for i = 1:length(rpm)]
theta_z_l = [4*atan(linear_states[i].points[end].theta[3]/4)
    for i = 1:length(rpm)]

plot!(rpm, theta_z_nl, label=&quot;Nonlinear&quot;)
plot!(rpm, theta_z_l, label=&quot;Linear&quot;)
plot!(show=true)</code></pre><p><img src="../../assets/guide-theta_z.svg" alt/></p><h2 id="Other-Capabilities"><a class="docs-heading-anchor" href="#Other-Capabilities">Other Capabilities</a><a id="Other-Capabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Capabilities" title="Permalink"></a></h2><p>For information on how to use the other capabilities of this package see the examples or the <a href="../../reference/reference/#Public-API">Public API</a>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../cantilever/">Cantilever with a Uniform Load »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Tuesday 17 May 2022 21:40">Tuesday 17 May 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
